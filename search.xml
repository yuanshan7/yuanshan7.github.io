<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>资源汇总</title>
    <url>/2021/06/07/%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><p><strong><a href="https://zh.javascript.info/">现代JavaScript 教程</a></strong></p>
<p><strong><a href="https://www.javascriptcn.com/">JavaScript中文网(合集)</a></strong></p>
<h2 id="宝藏博主："><a href="#宝藏博主：" class="headerlink" title="宝藏博主："></a>宝藏博主：</h2><p><strong><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></strong></p>
<p><strong><a href="https://www.cnblogs.com/tugenhua0707/">龙恩0707</a></strong></p>
<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p><strong><a href="https://www.caniuse.com/">Can I Use</a></strong></p>
<p><strong><a href="https://element.eleme.cn/#/zh-CN">ElementUI</a></strong></p>
<p><strong><a href="https://www.swiper.com.cn/">轮播Swiper</a></strong></p>
<p><strong><a href="https://cesium.com/platform/cesiumjs/">cesium地图官网</a></strong></p>
<p><strong><a href="https://www.layui.com/">Layui</a></strong></p>
<p><strong><a href="https://lbsyun.baidu.com/jsdemo.htm#sLngLatSearchPath">百度地图 API示例</a></strong></p>
<p><strong><a href="https://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a2b3">百度地图 API说明</a></strong></p>
<p><strong><a href="http://www.papocket.com/patool/rgb2hex.html">RGB颜色值与十六进制颜色码转换工具</a></strong></p>
<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p><strong><a href="https://developer.mozilla.org/zh-CN/">MDN</a></strong></p>
<p><strong><a href="http://www.axios-js.com/zh-cn/docs/#axios-create-config">axios官网</a></strong></p>
<p><strong><a href="https://www.tslang.cn/">Typescript官网</a></strong></p>
<h2 id="资源类："><a href="#资源类：" class="headerlink" title="资源类："></a>资源类：</h2><p><strong><a href="https://www.iconfont.cn/">阿里图标库</a></strong></p>
<p><strong><a href="https://nipponcolors.com/#sora">配色(日本)</a></strong></p>
<p><strong><a href="https://flatuicolors.com/">配色2</a></strong></p>
<p><strong><a href="https://animejs.com/">animejsCSS动画引擎</a></strong></p>
<p><strong><a href="https://cubic-bezier.com/#.17,.67,.83,.67">CSS动画速度调节</a></strong></p>
<p><strong><a href="https://mycolor.space/">渐变色</a></strong></p>
<p><strong>网站模板</strong></p>
<p><strong><a href="http://www.templatesy.com/">模板网站一</a></strong></p>
<p><strong><a href="http://www.freemuban.com/">模板网站二</a></strong></p>
<p><strong>图片</strong></p>
<p><strong><a href="https://1x.com/magazine">1X</a></strong></p>
<p><strong><a href="https://pixabay.com/zh/">pixabay</a></strong></p>
<p><strong><a href="https://www.pexels.com/zh-cn/">pexels</a></strong></p>
<p><strong>其他</strong></p>
<p><strong><a href="https://msdn.itellyou.cn/">MSDN</a></strong></p>
<h2 id="Vue："><a href="#Vue：" class="headerlink" title="Vue："></a>Vue：</h2><p><strong><a href="https://cn.vuejs.org/">Vue官网</a></strong></p>
<p><strong><a href="https://router.vuejs.org/zh/">Vue Router</a></strong></p>
<p><strong><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">Vue API</a></strong></p>
<h2 id="React："><a href="#React：" class="headerlink" title="React："></a>React：</h2><p><strong><a href="https://react.docschina.org/">React官网</a></strong></p>
<h2 id="HTML："><a href="#HTML：" class="headerlink" title="HTML："></a>HTML：</h2><p><strong><a href="https://www.w3school.com.cn/html/index.asp">w3school</a></strong></p>
<h2 id="CSS："><a href="#CSS：" class="headerlink" title="CSS："></a>CSS：</h2><p><strong><a href="https://www.w3school.com.cn/css/index.asp">w3school</a></strong></p>
<h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><p><strong>官方</strong></p>
<p><strong><a href="https://www.aclweb.org/anthology/">ACL论文集</a></strong></p>
<p><strong><a href="https://www.storkapp.me/">文献鸟</a></strong></p>
<p><strong><a href="http://www.jos.org.cn/jos/ch/reader/issue_browser.aspx">软件学报</a></strong></p>
<p><strong><a href="https://dblp.uni-trier.de/">DBLP</a></strong></p>
<p><strong>个人</strong></p>
<p><strong><a href="https://www.cnblogs.com/shona/category/1525897.html">论文博客一</a></strong></p>
<h1 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h1><p><strong><a href="https://leetcode-cn.com/problemset/all/">Leetcode首页</a></strong></p>
<p><strong><a href="https://leetcode-cn.com/problemset/lcof/">Leetcode剑指offer</a></strong></p>
<p><strong><a href="https://bytedance.feishu.cn/base/appcntyT3yQWMaXTKvikBhimn1g?table=tbl96QXAbuvl2fev&view=vewJHSwJVd">如何准备前端技术面试？</a></strong></p>
<p><strong><a href="https://juejin.cn/post/6844904168377810958#heading-58">前端面经</a></strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局理解</title>
    <url>/2021/10/07/Flex%E5%B8%83%E5%B1%80%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>一、Flex布局的概念</p>
<p>Flexbox布局也叫Flex布局，弹性盒子布局。它的<strong>目标</strong>是提供一个更有效地布局、对齐方式，并且能够使父元素在子元素的大小未知或动态变化情况下仍然能够分配好子元素之间的间隙。<strong>主要思想</strong>是使父元素能够调整子元素的宽度、高度、排列方式，从而更好的适应可用的布局空间。设定为flex布局的元素能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。</p>
<p>Flex布局更适合小规模的布局，可以简便、完整、响应式的实现各种页面布局。但是，设为Flex布局以后，其子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。Flex弹性盒模型的优势在于只需声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。</p>
<p><img src="/2021/10/07/Flex%E5%B8%83%E5%B1%80%E7%90%86%E8%A7%A3/flex.png" alt="flex"></p>
<ol>
<li><p>容器属性：</p>
<ol>
<li><code>flex-direction</code>：该属性决定主轴方向。</li>
<li><code>flex-wrap</code>：决定是否换行。取值为<code>nowrap、wrap、wrap-reverse</code>。</li>
<li><code>flex-flow</code>：上两个属性的简写。</li>
<li><code>justify-content</code>：定义项目在主轴上的对齐方式。</li>
<li><code>align-items</code>：定义项目在交叉轴上的对齐方式。</li>
<li><code>align-content</code>：定义多根轴线的对齐方式。</li>
</ol>
</li>
<li><p>项目属性：</p>
<ol>
<li><code>order</code>：定义项目的排列方式，数值越小越靠前。</li>
<li><code>flex-grow</code>：定义项目的放大比例，默认为0，即如果存在剩余空间也不放大。</li>
<li><code>flex-shrink</code>：定义项目的缩小比例，默认为1，即空间不足也不缩小。</li>
<li><code>flex-basis</code>：定义在分配多余空间之前，项目占据主轴的空间，浏览器根据该值，计算主轴是否有多余空间。会先参考<code>width</code>、<code>max-content</code>的值，将其设置为<code>flex-basis</code>的值。</li>
<li><code>flex</code>：以上三个属性的简写。<ol>
<li><code>initial: 0 1 auto</code>。</li>
<li><code>auto: 1 1 auto</code>。</li>
<li><code>none: 0 0 auto</code>。</li>
</ol>
</li>
<li><code>align-self</code>：该属性允许项目具有不同的对齐方式，该属性覆盖父元素的<code>align-items</code>属性。</li>
</ol>
<p> 参考链接：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解this指向</title>
    <url>/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="一、this的默认绑定"><a href="#一、this的默认绑定" class="headerlink" title="一、this的默认绑定"></a>一、this的默认绑定</h2><p><strong>1.全局环境下的this指向了window</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/1.png"></p>
<p><strong>2.函数独立调用，函数内部的this也指向了window</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/2.png"></p>
<p><strong>3.被嵌套的函数独立调用时，this默认指向了window</strong></p>
<p>​    当函数当做对象的方法来调用，this指向了obj</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/3.png"></p>
<p><strong>4.IIFE 自执行函数中内部的this指向了window</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/4.png"></p>
<p><strong>5.闭包中的this默认指向了window</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/5.png"></p>
<h2 id="二、隐式绑定"><a href="#二、隐式绑定" class="headerlink" title="二、隐式绑定"></a>二、隐式绑定</h2><p><strong>当函数当作方法来调用，this指向了直接对象</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/6.png"></p>
<h2 id="三、隐式丢失"><a href="#三、隐式丢失" class="headerlink" title="三、隐式丢失"></a>三、隐式丢失</h2><p>隐式丢失就是指隐式绑定的函数丢失了绑定对象，从而默认绑定到了window。</p>
<p><strong>注意：这种情况非常常见并且比较容易出错</strong></p>
<p><strong>1.隐式丢失 函数别名</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/7.png"></p>
<p>等价于</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/8.png"></p>
<p><strong>2.参数传递</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/9.png"></p>
<p>相当于</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/10.png"></p>
<p><strong>3.内置函数</strong></p>
<p>内置函数setTimeout()和setInterval()第一个参数的回调函数中的this默认值指向了window，跟第二种情况类似</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/11.png"></p>
<p><strong>4.间接调用</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/12.png"></p>
<p><strong>5.其他情况</strong></p>
<p>指向了window的特殊情况</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/13.png"></p>
<h2 id="四、显示绑定"><a href="#四、显示绑定" class="headerlink" title="四、显示绑定"></a>四、显示绑定</h2><p>call() apply() bind()把对象绑定到this上，叫做显示绑定。</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/14.png"></p>
<p>硬绑定</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/15.png"></p>
<p>数组的forEach()</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/16.png"></p>
<p>forEach()中的第二个参数可以用于改变内部回调函数的this指向</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/17.png"></p>
<p>并且一下类似的方法都有上面的性质</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/18.png"></p>
<h2 id="五、new绑定"><a href="#五、new绑定" class="headerlink" title="五、new绑定"></a>五、new绑定</h2><p>如果是new关键字来执行函数，相当于构造函数来实例化对象，那么内部的this指向了当前的实例化对象</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/19.png"></p>
<p>使用return关键字返回对象的时候，实例化出来的对象就是当前的返回对象</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/20.png"></p>
<p>实例化出来的对象内部的属性constructor属性指向了当前的构造函数</p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/21.png"></p>
<h2 id="六、严格模式下的this的指向"><a href="#六、严格模式下的this的指向" class="headerlink" title="六、严格模式下的this的指向"></a>六、严格模式下的this的指向</h2><p><strong>1.独立调用的函数内部的this指向了undefined</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/22.png"></p>
<p><strong>2.函数apply()和call()</strong></p>
<p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/23.png"></p>
<h2 id="七、this总结"><a href="#七、this总结" class="headerlink" title="七、this总结"></a>七、this总结</h2><p><img src="/2021/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91/24.png"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>useMemo和useEffect区别</title>
    <url>/2021/09/07/useMemo%E5%92%8CuseEffect%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>​    useMemo和useEffect是都属于React Hooks，我们知道在react中当数据变化会导致页面重新渲染，也就是更改了DOM。</p>
<p>​    useEffect又称为副作用，原因是它的运行时间在页面渲染之后进行，也就是当我们数据改变，触发了页面的重新渲染，渲染完成后触发useEffect，所以可以理解为一种页面渲染的回调函数。</p>
<p>​    useMemo与useEffect区别在于useMemo是在数据改变，页面渲染之前触发的，相当于页面渲染的一种前置操作。更详细的理解和其他hooks的理解期待后面的学习！</p>
<p>参考链接：</p>
<p><a href="https://www.jianshu.com/p/94ace269414d">https://www.jianshu.com/p/94ace269414d</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>问题解决日志</title>
    <url>/2021/08/25/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="2021-8-25"><a href="#2021-8-25" class="headerlink" title="2021-8-25"></a><strong>2021-8-25</strong></h2><p><strong>React项目中配置代理解决跨域的两种方案：</strong></p>
<p>首先明确一点在本地运行的前端项目都需要跑在本地服务器上，也就是<a href="http://localhost:3000/">http://localhost:3000/</a> 或<a href="http://localhost:8080/">http://localhost:8080/</a> 云云，而request.js文件中baseURL需要设置为localhost，明确这一步是因为目前在react项目中，还没找到像在vue中一样可以自动识别开发环境和生产环境得配置文件，如src-&gt;config-&gt;index.js文件，以下图为例，后续争取处理这个问题</p>
<p><img src="/2021/08/25/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%97%A5%E5%BF%97/1.png" alt="图一"></p>
<p><strong>方案一：</strong></p>
<p>在项目src文件夹同级目录下的package.json中，加入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>: <span class="string">&quot;http://xx.xxx.xx.xx:xxxx&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%97%A5%E5%BF%97/2.png" alt="图一"></p>
<p>这里所填的地址就是项目真正想要请求的地址，即中间件提供的地址，个人理解这里的代理就是原来项目在本地跑，如果要请求中间件提供的数据就需要向该网址发送请求，但是由于协议，域名，端口号不同产生跨域问题，就在此配置这一句作为一个中间代理人进行转发和接收，来解决跨域问题。</p>
<p><strong>方案二：</strong></p>
<p>在项目的src文件夹下新建一个名为setupProxy.js的文件，文件内容如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 貌似是react2.x以后的写法</span></span><br><span class="line"><span class="comment">// const proxy = require(&#x27;http-proxy-middleware&#x27;);</span></span><br><span class="line"><span class="comment">// 貌似是react1.x以后的写法</span></span><br><span class="line"><span class="keyword">const</span> &#123;createProxyMiddleware&#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(</span><br><span class="line">    createProxyMiddleware(<span class="string">&#x27;/api&#x27;</span>, &#123;  <span class="comment">//`api`是需要转发的请求 </span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://xx.xxx.xx.xx:xxxx&#x27;</span>,  <span class="comment">// 这里是接口服务器地址</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方案任选其中一种都可解决跨域问题！亲测！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>解决</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域原理及其解决办法</title>
    <url>/2021/08/15/%E8%B7%A8%E5%9F%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/qq_37629078/article/details/103479228?utm_term=%E6%98%93%E5%B0%8F%E5%9D%87%E8%B7%A8%E5%9F%9F&amp;utm_medium=distribute.wap_search_result.none-task-blog-2~all~sobaiduweb~default-0-103479228&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/qq_37629078/article/details/103479228?utm_term=%E6%98%93%E5%B0%8F%E5%9D%87%E8%B7%A8%E5%9F%9F&amp;utm_medium=distribute.wap_search_result.none-task-blog-2~all~sobaiduweb~default-0-103479228&amp;spm=1018.2118.3001.4187</a></p>
<p>​        跨域，指的是从一个域名去请求另外一个域名的资源，即跨域名请求。跨域时，浏览器不能执行其他域名网站的脚本，这是由浏览器的同源策略造成的，是浏览器施加的安全限制， 跨域限制访问，其实是浏览器的限制。 同源策略是浏览器最核心也最基本的安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源 ，这是一个用于隔离潜在恶意文件的重要安全机制。所以跨域问题只在浏览器中出现，如果客户端是APP的话，那跨域问题就不存在了。 PS：IE端口除外，IE对同源策略的定义有略微的不同，具体可以查看文末给出的同源策略的链接。</p>
<p><strong>状态码：</strong></p>
<p>1xx：请求收到，继续处理<br> 2xx：操作成功收到，分析、接受<br> 3xx：完成此请求必须进一步处理<br> 4xx：请求包含一个错误语法或不能完成<br> 5xx：服务器执行一个完全有效请求失败<br> 100——客户必须继续发出请求<br> 101——客户要求服务器根据请求转换HTTP协议版本<br> 200——交易成功<br> 201——提示知道新文件的URL<br> 202——接受和处理、但处理未完成<br> 203——返回信息不确定或不完整<br> 204——请求收到，但返回信息为空<br> 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br> 206——服务器已经完成了部分用户的GET请求<br> 300——请求的资源可在多处得到<br> 301——删除请求数据<br> 302——在其他地址发现了请求数据<br> 303——建议客户访问其他URL或访问方式<br> 304——客户端已经执行了GET，但文件未变化<br> 305——请求的资源必须从服务器指定的地址得到<br> 306——前一版本HTTP中使用的代码，现行版本中不再使用<br> 307——申明请求的资源临时性删除<br> 400——错误请求，如语法错误<br> 401——请求授权失败<br> 402——保留有效ChargeTo头响应<br> 403——请求不允许<br> 404——没有发现文件、查询或URl<br> 405——用户在Request-Line字段定义的方法不允许<br> 406——根据用户发送的Accept拖，请求资源不可访问<br> 407——类似401，用户必须首先在代理服务器上得到授权<br> 408——客户端没有在用户指定的饿时间内完成请求<br> 409——对当前资源状态，请求不能完成<br> 410——服务器上不再有此资源且无进一步的参考地址<br> 411——服务器拒绝用户定义的Content-Length属性请求<br> 412——一个或多个请求头字段在当前请求中错误<br> 413——请求的资源大于服务器允许的大小<br> 414——请求的资源URL长于服务器允许的长度<br> 415——请求资源不支持请求项目格式<br> 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段。<br> 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求。<br> 500——服务器产生内部错误<br> 501——服务器不支持请求的函数<br> 502——服务器暂时不可用，有时是为了防止发生系统过载<br> 503——服务器过载或暂停维修<br> 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长<br> 505——服务器不支持或拒绝支请求头中指定的HTTP版本</p>
<p><strong>几个重要的HTTP头</strong></p>
<p>  Origin： 存在于请求中<strong>，</strong>用于指明当前请求来自于哪个站点， Origin 仅仅包含站点信息，不包含任何路径信息。</p>
<p>  Host：客户端指定自己想访问的HTTP服务器的域名/IP 地址和端口号。</p>
<p>  Referer： 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p>
<p>  Access-Control-Allow-Origin： 它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求 。</p>
<p>  Access-Control-Expose-Headers ：CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p>
<p>  Access-Control-Request-Method ： 用来列出浏览器的CORS请求会用到哪些HTTP方法 。</p>
<p>  Access-Control-Request-Headers ： 指定浏览器CORS请求会额外发送的头信息字段。</p>
<p>  Access-Control-Allow-Methods： 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。</p>
<p>  Access-Control-Allow-Headers： 表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p>  Access-Control-Allow-Credentials： 它的值是一个布尔值，表示是否允许浏览器发送请求时带上Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 值得注意的是：Access-Control-Allow-Credentials为true时，Access-Control-Allow-Origin 的值不能为 *</p>
<p>  Access-Control-Max-Age：用来指定本次预检请求的有效期，单位为秒。 非简单请求每次会发出两条请求，这样自然会影响我们的效率，HTTP协议里面增加了一个响应头可以用来缓存我们的预检命令，这样在缓存有效内就不再需要发送预检请求了。</p>
<p><strong>更多参考：</strong><br>浏览器的同源策略：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>
<p>跨域资源共享：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">https://developer.mozilla.org/zh-CN/docs/Glossary/CORS</a></p>
<p>简单头部：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AE%80%E5%8D%95%E5%A4%B4%E9%83%A8">https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AE%80%E5%8D%95%E5%A4%B4%E9%83%A8</a></p>
<p>预检请求：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/preflight_request">https://developer.mozilla.org/zh-CN/docs/Glossary/preflight_request</a></p>
<p>HTTP Headers：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</a></p>
<p>HTTP访问控制（CORS）：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests</a></p>
<p>postMessage：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p>
<p>Document.domain：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么有两种形式的交叉熵损失函数？</title>
    <url>/2021/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F/</url>
    <content><![CDATA[<p>在学习机器学习的时候，我们会看到两个长的不一样的交叉熵损失函数。<br>假设我们现在有一个样本 { x , t } { x,t}{x,t}，这两种损失函数分别是。</p>
<p><img src="/2021/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F/1.png"></p>
<p>这两个都是交叉熵损失函数，但是看起来长的却有天壤之别。为什么同是交叉熵损失函数，长的却不一样呢？</p>
<p>因为这两个交叉熵损失函数对应不同的最后一层的输出。第一个对应的最后一层是softmax，第二个对应的最后一层是sigmoid。</p>
<p>如果看到这个答案就明白了的话，就没必要往下看了，如果感觉云里雾里的话，请听细细分解。</p>
<p>首先来看信息论中交叉熵的定义：</p>
<p><img src="/2021/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F/2.png"></p>
<p>交叉熵是用来描述两个分布的距离的，神经网络训练的目的就是使 g ( x ) g(x)g(x) 逼近 p ( x ) p(x)p(x)。</p>
<p>现在来看softmax作为最后一层的情况。g ( x ) g(x)g(x)是什么呢？就是最后一层的输出 y yy 。p ( x ) p(x)p(x)是什么呢？就是我们的one-hot标签。我们带入交叉熵的定义中算一下，就会得到第一个式子：</p>
<p><img src="/2021/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F/3.png"></p>
<p>j:样本x属于第j类。</p>
<p>再来看sigmoid作为最后一层的情况。sigmoid作为最后一层输出的话，那就不能把最后一层的输出看作成一个分布了，因为加起来不为1。现在应该将最后一层的每个神经元看作一个分布，对应的 target属于二项分布(target的值代表是这个类的概率)，那么第 i 个神经元交叉熵为：</p>
<p><img src="/2021/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F/4.png"></p>
<p>所以最后一层总的交叉熵损失函数是</p>
<p><img src="/2021/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F/5.png"></p>
<p><strong>解释完了，最后总结一下：这两个长的不一样的交叉熵损失函数实际上是对应的不同的输出层。</strong></p>
<p>参考：<a href="https://blog.csdn.net/u012436149/article/details/69660214">https://blog.csdn.net/u012436149/article/details/69660214</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的call()和apply()</title>
    <url>/2021/07/30/JS%E4%B8%AD%E7%9A%84call-%E5%92%8Capply/</url>
    <content><![CDATA[<p>每个函数都包含两个非继承而来的方法：call()和apply()；</p>
<p>在JavaScript中，call和apply作用是一样的，都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部this的指向。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的数组操作</title>
    <url>/2021/07/29/JS%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>虽然ECMAScript数组与其他语言中的数组都是数据的有序列表，但是ECMAScript数组的每一项都可以保存为任何类型的数据，也就是说数组的第一项可以用来保存字符串，而第二项可以用来保存数值；此外数组的大小也是可以动态调整的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button onclick=&quot;newArray()&quot;&gt;测试&lt;/button&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// at(index) 返回index参数处的元素</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// concat() 合并两个数组，由前面的数组调用该方法，参数为后面的数组,可以添加多个数组</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// constructor() 返回对创建该对象的数组函数的引用 ƒ Array() &#123; [native code] &#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// copyWithin(target,start,end) 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// entries() 把一个对象的键值以数组的形式遍历出来，结果和 for…in 一致，但不会遍历原型属性。是对键值对的遍历</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// push() js中的栈方法之一，该方法方法可以接收任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后的数组的长度。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// pop() js中的栈方法之一，该方法可以从数组末尾移除最后一项，减少数组的length值，然后返回移除的项</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// shift() js中的队列方法之一，它能够移除并返回数组的第一个元素，同时将数组的长度减一</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// unshift() js中队列方法之一，它能够向数组的开头添加一个或更多元素，并返回新的长度。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 注意：同时使用shift()和push()可以模拟队列对数组进行操作，同时使用unshift()和pop()可以从相反的方向来模拟队列</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// sort()对数组的元素进行排序,如果是数值则从小到大，如果是字符则按字母顺序，如果是汉字则按拼音首字母顺序排列,如果是对象则貌似不改变数组顺序</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reverse() 颠倒数组中元素的顺序,目测对所有类型有效</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// slice() 从某个已有的数组返回选定的元素，接收一个或两个参数，一个参数时返回从参数位置到最后一项；两个参数时返回起始和结束位置之间的项，但不包括结束位置的项</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// splice() 恐怕是最强大的数组方法？？</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 只有一个参数时表示从该位置开始一直到数组末尾全部删除</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 两个参数表示删除数组中的一段数据,第一个参数为删除的起始位置，第二个参数为删除的终止位置，第二个参数不包括在内</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 三个参数时，第一个参数表示删除的起始位置，第二个参数表示输出的个数，第三个位置开始表示要想数组中删除位置处添加的项</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 当将删除的数量设置为0时，第三个参数以后都为要添加的项</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 若想替换数组中某一项或某几项的值，则可以设置删除1项或n项，从第三个参数开始写入要添加的项，所添加的项和第二个参数中删除的数量无关，可多可少可相等</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// indexOf() 位置方法之一，表示要查找的项和（可选的）表示查找起点位置的索引，从数组的开头开始查找，注意该方法在比较第一个参数与数组中的每一项时，会使用全等操作符，必须严格相等</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// lastIndexOf() 位置方法之一，表示要查找的项和（可选的）表示查找起点位置的索引，从数组的末尾开始查找，注意该方法在比较第一个参数与数组中的每一项时，会使用全等操作符，必须严格相等</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 注意：indexOf和lastIndexOf找到后返回的值都是数组中从前往后的index值，二者的区别在于indexOf是按照从前往后的顺序查找，返回找到的第一个符合要求，也就是与查找条件相等的元素的index信息；</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 而lastIndexOf是从后往前找，返回找到的第一个符合要求，也就是与查找条件相等的index信息，而此index不因查找方向而改变。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 以下均为迭代方法，每个方法都接收两个参数，要在每一项上运行的函数和（可选的）运行该函数的作用域对象，影响this的值；以下方法都不会修改数组中包含的值 </span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// every() 迭代方法之一，参数为一个函数，函数入参为数组中的每一项，只有当数组中的每一项都满足函数条件，函数才会返回true，否则返回false</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// some() 迭代方法之一，参数为一个函数，函数入参为数组中的每一项，只要当数组中的任意一项满足函数条件，函数就会返回true，否则返回false</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// filter() 迭代方法之一，创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// forEach() 迭代方法之一，方法用于调用数组的每一个元素，并将元素传递给回调函数。array.forEach(function(currentValue, index, arr), thisValue)</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 需要详细了解 </span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// map() 迭代方法之一，按照原始数组元素顺序依次处理元素,返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值.function(currentValue,index,arr),currentValue 必须 当前元素值, index 可选 当前元素的索引值,arr 可选 当前元素属于的数组对象。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// fill() 使用制定的元素填充数组，其实就是用默认内容初始化数组,arr.fill(value, start, end),value：填充值,start：填充起始位置，可以省略,end：填充结束位置，可以省略，实际结束位置是end-1</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// find()</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// findIndex()</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reduce() 方法接收个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 arr.reduce(callback,[initialValue])</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reduceRight() [从右往左开始计算]方法接收个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 arr.reduce(callback,[initialValue])</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// flat()</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// flatMap()  </span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// includes()</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// keys()</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// join()把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// toLocaleString()把数组转换为本地数组，并返回结果</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// toString()把数组转换为字符串，并返回结果</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// values()</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// Symbol(Symbol.iterator)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// Symbol(Symbol.unscopables)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// toSource()返回该对象的源代码。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// valueOf()返回数组对象的原始值</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 选择执行函数</span></span></span><br><span class="line"><span class="javascript">  flatArray();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 创建一个新数组</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">newArray</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array1 = []; <span class="comment">//创建一个数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array2 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组并指定长度，注意不是上限，是长度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">//创建一个导长度为5的数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array4 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">//创建一个数组并赋值</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.length)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.length)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array3)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array3.length)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array4)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array4.length)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">joinArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tmp = array.join(<span class="string">&#x27;-&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;tmp&#x27;</span>, tmp)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;array&#x27;</span>, array)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 返回值是一个新的变量，而不是存在原来的array中</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.join(<span class="string">&#x27;-&#x27;</span>))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以用于数组查看有哪些方法</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array.__proto__)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// at(index) 返回index参数处的元素</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">atArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.at(<span class="number">1</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.at(<span class="number">9</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.at(-<span class="number">5</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">`array`</span>, array)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// concat() 合并两个数组，由前面的数组调用该方法，参数为后面的数组,可以添加多个数组</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">concatArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>]</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.concat(array2))</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array2.concat(array1))</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// constructor() 返回对创建该对象的数组函数的引用 ƒ Array() &#123; [native code] &#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">constructorArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.constructor);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (array.constructor == <span class="built_in">Array</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&quot;This is an Array&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;This is an Array&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (array.constructor == <span class="built_in">Boolean</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&quot;This is a Boolean&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (array.constructor == <span class="built_in">Date</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&quot;This is a Date&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (array.constructor == <span class="built_in">String</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&quot;This is a String&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// copyWithin(target,start,end) 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">copyWithinArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// target （必需）：从该位置开始替换数据。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// start （可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// end （可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 注意该方法返回的值是存在原数组中，所以该方法会改变数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>, -<span class="number">4</span>, -<span class="number">1</span>))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// entries() 把一个对象的键值以数组的形式遍历出来，结果和 for…in 一致，但不会遍历原型属性。</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">entriesArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tmp = array.entries();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tmp1 = array1.entries();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp.next().value)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp.next().value)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp.next().value)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp.next().value)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp1.next().value)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp1.next().value)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp1.next().value)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp1.next().value)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tmp1 <span class="keyword">instanceof</span> <span class="title">constructor</span>)</span></span><br><span class="line"><span class="javascript">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="keyword">typeof</span> tmp1</span>)</span></span><br><span class="line"><span class="javascript">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">tmp1</span>)</span></span><br><span class="line"><span class="javascript">    // <span class="title">Object</span>.<span class="title">prototype</span>.<span class="title">toString</span>.<span class="title">call</span>(<span class="params"></span>)用于判断数据类型</span></span><br><span class="line"><span class="javascript">    // <span class="title">toString</span>是<span class="title">Object</span>原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 <span class="title">toString</span>运行时<span class="title">this</span>指向的对象类型, 返回的类型格式为[<span class="title">object</span>,<span class="title">xxx</span>],<span class="title">xxx</span>是具体的数据类型</span></span><br><span class="line"><span class="javascript">    // 其中包括：<span class="title">String</span>,<span class="title">Number</span>,<span class="title">Boolean</span>,<span class="title">Undefined</span>,<span class="title">Null</span>,<span class="title">Function</span>,<span class="title">Date</span>,<span class="title">Array</span>,<span class="title">RegExp</span>,<span class="title">Error</span>,<span class="title">HTMLDocument</span>,... 基本上所有对象的类型都可以通过这个方法获取到。</span></span><br><span class="line"><span class="javascript">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="built_in">Object</span>.prototype.toString.call(tmp1)</span>)</span></span><br><span class="line"><span class="javascript">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="built_in">Object</span>.prototype.toString.call(array)</span>)</span></span><br><span class="line"><span class="javascript">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    // <span class="title">for</span> <span class="title">in</span>遍历的是数组的索引（即键名），而<span class="title">for</span> <span class="title">of</span>遍历的是数组元素值。所以<span class="title">for</span> <span class="title">in</span>更适合遍历对象，不要使用<span class="title">for</span> <span class="title">in</span>遍历数组。</span></span><br><span class="line"><span class="javascript">    <span class="title">for</span> (<span class="params"><span class="keyword">let</span> e <span class="keyword">of</span> tmp1</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(tmp1)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// push() js中的栈方法之一，该方法方法可以接收任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后的数组的长度。</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">pushArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.push(<span class="number">9</span>), array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.push(<span class="string">&#x27;lipu&#x27;</span>), array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.push(<span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>), array1)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// pop() js中的栈方法之一，该方法可以从数组末尾移除最后一项，减少数组的length值，然后返回移除的项</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">popArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.pop(), array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.pop(), array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.pop(), array2)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.push(110,111,112),array1)</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// shift() js中的队列方法之一，它能够移除并返回数组的第一个元素，同时将数组的长度减一=</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">shiftArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.shift(), array1)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// unshift() js中队列方法之一，它能够向数组的开头添加一个或更多元素，并返回新的长度。</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">shiftArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.unshift(<span class="number">10</span>, <span class="number">11</span>), array1)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// sort()对数组的元素进行排序,如果是数值则从小到大，如果是字符则按字母顺序，如果是汉字则按拼音首字母顺序排列,如果是对象则貌似不改变数组顺序</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array3 = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array4 = [<span class="string">&quot;我&quot;</span>, <span class="string">&quot;不&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;药&quot;</span>, <span class="string">&quot;神&quot;</span>]</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array5 = [</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;20&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;19&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;jordan&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">    ]</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.sort())</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.sort())</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array3.sort())</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array4.sort())</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array5.sort())</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reverse()颠倒数组中元素的顺序,目测对所有类型有效</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">reverseArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array5 = [</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;20&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;19&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;jordan&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">    ]</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.reverse())</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.reverse())</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array5.reverse())</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// slice()从某个已有的数组返回选定的元素，接收一个或两个参数，一个参数时返回从参数位置到最后一项；两个参数时返回起始和结束位置之间的项，但不包括结束位置的项</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">sliceArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.slice(<span class="number">1</span>, <span class="number">2</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.slice(<span class="number">1</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.slice(-<span class="number">1</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.slice(-<span class="number">3</span>, -<span class="number">1</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.slice(-<span class="number">1</span>, -<span class="number">3</span>))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// splice() 恐怕是最强大的数组方法？？</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">spliceArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 只有一个参数时表示从该位置开始一直到数组末尾全部删除</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(2),array1)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 两个参数表示删除数组中的一段数据,第一个参数为删除的起始位置，第二个参数为删除的终止位置，第二个参数不包括在内</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(0,2),array1)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 三个参数时，第一个参数表示删除的起始位置，第二个参数表示输出的个数，第三个位置开始表示要想数组中删除位置处添加的项</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 当将删除的数量设置为0时，第三个参数以后都为要添加的项</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(2,0,99),array1)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(2,0,99,100),array1)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 若想替换数组中某一项或某几项的值，则可以设置删除1项或n项，从第三个参数开始写入要添加的项，所添加的项和第二个参数中删除的数量无关，可多可少可相等</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(2,1,100),array1)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(2,2,100),array1)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(array1.splice(2,2,100,101,102),array1)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// indexOf() 位置方法之一，表示要查找的项和（可选的）表示查找起点位置的索引，从数组的开头开始查找，注意该方法在比较第一个参数与数组中的每一项时，会使用全等操作符，必须严格相等</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">indexOfArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.indexOf(<span class="number">6</span>), array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.lastIndexOf(<span class="number">6</span>), array1)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.indexOf(<span class="string">&#x27;james&#x27;</span>), array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.indexOf(<span class="string">&#x27;James&#x27;</span>), array2)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// lastIndexOf() 位置方法之一，表示要查找的项和（可选的）表示查找起点位置的索引，从数组的末尾开始查找，注意该方法在比较第一个参数与数组中的每一项时，会使用全等操作符，必须严格相等</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">lastIndexOfArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.indexOf(<span class="number">6</span>), array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.lastIndexOf(<span class="number">6</span>), array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.lastIndexOf(<span class="string">&#x27;james&#x27;</span>), array2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array2.lastIndexOf(<span class="string">&#x27;James&#x27;</span>), array2)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// every() 迭代方法之一，参数为一个函数，函数入参为数组中的每一项，只有当数组中的每一项都满足函数条件，函数才会返回true，否则返回false</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">everyArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> item &gt; <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125;))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> item &gt; <span class="number">3</span></span></span><br><span class="line"><span class="javascript">    &#125;))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// some() 迭代方法之一，参数为一个函数，函数入参为数组中的每一项，只要当数组中的任意一项满足函数条件，函数就会返回true，否则返回false</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">someArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> item &gt; <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125;))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> item &gt; <span class="number">3</span></span></span><br><span class="line"><span class="javascript">    &#125;))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> item &gt; <span class="number">7</span></span></span><br><span class="line"><span class="javascript">    &#125;))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// filter() 迭代方法之一，创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">filterArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> item &gt; <span class="number">5</span></span></span><br><span class="line"><span class="javascript">    &#125;))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// forEach() 方法用于调用数组的每一个元素，并将元素传递给回调函数。array.forEach(function(currentValue, index, arr), thisValue)</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">forEachArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">// item必填，指当前元素；index可选，指当前元素的索引；arr可选，指当前元素所属的对象；</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span> =&gt; <span class="subst">$&#123;index&#125;</span> =&gt; <span class="subst">$&#123;arr&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this)</span></span></span><br><span class="line"><span class="javascript">    &#125;), <span class="built_in">this</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// map() 按照原始数组元素顺序依次处理元素,返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值.function(currentValue,index,arr),currentValue 必须 当前元素值, index 可选 当前元素的索引值,arr 可选 当前元素属于的数组对象。</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">mapArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    array1.map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      item += <span class="number">3</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(item, index, arr)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// fill() 使用制定的元素填充数组，其实就是用默认内容初始化数组,arr.fill(value, start, end),value：填充值,start：填充起始位置，可以省略,end：填充结束位置，可以省略，实际结束位置是end-1</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">fillArray</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.fill(<span class="number">99</span>, <span class="number">2</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1.fill(<span class="number">7</span>))</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(array1)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">findArray</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">findIndexArray</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reduce() 方法接收个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 arr.reduce(callback,[initialValue])</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">reduceArray</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// callback中的四个参数分别为（上一次调用回调返回的值，或者是提供的初始值；数组中当前被处理的元素；当前元素在数组中的索引；调用 reduce 的数组），可选参数initialValue （作为第一次调用 callback 的第一个参数。）</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> sum = array1.reduce(<span class="function">(<span class="params">prev, cur, index, arr</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(prev, cur, index)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> prev + cur</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="number">50</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reduceRight() [从右往左开始计算]方法接收个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 arr.reduce(callback,[initialValue])</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">reduceRightArray</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> array2 = [<span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Kobe&#x27;</span>, <span class="string">&#x27;Jordan&#x27;</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// callback中的四个参数分别为（上一次调用回调返回的值，或者是提供的初始值；数组中当前被处理的元素；当前元素在数组中的索引；调用 reduce 的数组），可选参数initialValue （作为第一次调用 callback 的第一个参数。）</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> sum = array1.reduceRight(<span class="function">(<span class="params">prev, cur, index, arr</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(prev, cur, index)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> prev + cur</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="number">50</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">flatArray</span>(<span class="params">params</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">2</span>, [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>], <span class="string">&#x27;g&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Number</span>(item)</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(flat(arr))</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>IntersectionObserver</title>
    <url>/2021/07/23/IntersectionObserver/</url>
    <content><![CDATA[<p><strong>IntersectionObserver接口</strong>(从属于<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer API</a>) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">viewport</a>)交叉状态的方法。祖先元素与视窗(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">viewport</a>)被称为<strong>根(root)。</strong></p>
<p>当一个<code>IntersectionObserver</code>对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦IntersectionObserver被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="built_in">this</span>.test());</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getThreshold: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">1.0</span>; i += <span class="number">0.005</span>) &#123;</span><br><span class="line">          data.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">mountObserver</span>: <span class="function">(<span class="params">&#123; target, handler, threshold &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> options = &#123;</span><br><span class="line">          <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">          <span class="attr">rootMargin</span>: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">          threshold</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(handler, options);</span><br><span class="line">        observer.observe(target);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">handleChanges</span>(<span class="params">entries</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(entries)</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">&#123; target, intersectionRatio &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 当前区域元素</span></span><br><span class="line">          <span class="built_in">console</span>.log(target)</span><br><span class="line">          <span class="comment">// 当前区域的占比数值，如0.9167556166648865</span></span><br><span class="line">          <span class="built_in">console</span>.log(intersectionRatio)</span><br><span class="line">          <span class="comment">// 选择当前区域元素下想要操作的详细元素</span></span><br><span class="line">          <span class="keyword">const</span> element = target.querySelector(<span class="string">&#x27;.percentage__value&#x27;</span>);</span><br><span class="line">          <span class="comment">// 以空格分割当前区域元素类名，取第二位的类名</span></span><br><span class="line">          <span class="keyword">const</span> view = target.className.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">          <span class="comment">// math.ceil(x)返回大于等于参数x的最小整数，乘以100将小数转化为百分比数值</span></span><br><span class="line">          <span class="keyword">const</span> percentage = <span class="built_in">Math</span>.ceil(intersectionRatio * <span class="number">100</span>);</span><br><span class="line">          <span class="comment">// 将百分比数值赋给元素展示到页面</span></span><br><span class="line">          element.firstChild.data = percentage;</span><br><span class="line">          <span class="comment">// 调用变色函数</span></span><br><span class="line">          <span class="built_in">this</span>.scaleLegendBg(&#123;</span><br><span class="line">            <span class="attr">bg</span>: <span class="built_in">document</span>.querySelector(<span class="string">`.legend__item--<span class="subst">$&#123;view&#125;</span>`</span>).querySelector(<span class="string">&#x27;.legend__bg&#x27;</span>),</span><br><span class="line">            <span class="attr">percentage</span>: percentage / <span class="number">100</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">scaleLegendBg</span>(<span class="params">&#123; bg, percentage &#125;</span>)</span> &#123;</span><br><span class="line">        bg.style.transform = <span class="string">`scaleX(<span class="subst">$&#123;percentage&#125;</span>)`</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> views = [<span class="string">&#x27;.home&#x27;</span>, <span class="string">&#x27;.about&#x27;</span>, <span class="string">&#x27;.contact&#x27;</span>, <span class="string">&#x27;.services&#x27;</span>];</span><br><span class="line">        views.map(<span class="function">(<span class="params">view</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.mountObserver(&#123;</span><br><span class="line">            <span class="attr">target</span>: <span class="built_in">document</span>.querySelector(view),</span><br><span class="line">            <span class="attr">handler</span>: <span class="built_in">this</span>.handleChanges,</span><br><span class="line">            <span class="attr">threshold</span>: <span class="built_in">this</span>.getThreshold()</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>简述JavaScript Event Loop</title>
    <url>/2021/07/15/%E7%AE%80%E8%BF%B0JavaScript-Event-Loop/</url>
    <content><![CDATA[<p>JavaScript是一门单线程的语言，其异步和多线程的实现是通过Event Loop(事件循环)来实现的，大体来说一共有三个部分组成：</p>
<p><strong>调用栈（call stack）</strong></p>
<p><strong>消息队列（Message Queue）</strong></p>
<p><strong>微任务队列（Microtask Queue）</strong></p>
<p><img src="/2021/07/15/%E7%AE%80%E8%BF%B0JavaScript-Event-Loop/%E8%B0%83%E7%94%A8%E6%A0%88-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.png" alt="调用栈-消息队列-微任务队列"></p>
<p>Event Loop开始时，会从全局DOM开始一行一行执行，当遇到函数调用，会把其压入调用栈中</p>
<p>当遇到setTimeout(){}时，首先会将一整个setTimeout(){}放入定时器线程执行，当时间到了，再把setTimeout()中的回调函数，也就是{}中的内容放入到消息队列中，这一部分消息会在栈清空的时候执行，这也是为什么setTimeout()中的延迟参数知识最小延迟的时间，当包裹setTimeout()的函数执行完毕时，调用栈清空，消息队列中的消息会被压入到调用栈中执行</p>
<p>而使用promise async await创建的异步操作会加入到微任务队列中，它会在调用栈被清空的时候立即执行，并且处理期间，新加入的微任务也会一同执行；因此当调用栈被清空，而消息队列和微任务队列都同时有待执行的消息或任务时，会先将微任务队列中的任务放入到调用栈中调用，当微任务队列清空后，才会执行消息队列中的消息</p>
<p>即优先级排序为</p>
<p><strong>调用栈 &gt; 任务队列 &gt; 消息队列</strong></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/2021/07/04/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/2021/07/04/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/lifecycle.png" alt="Vue官网生命周期"></p>
<p>什么是生命周期：从Vue实例创建、运行、到销毁期问，总是伴随着各种各样的事件，这些事件统称为生命周期！<br>生命周期钩子：就是生命周期事件的别名而已。</p>
<p>（生命周期钩子 = 生命周期函数 = 生命周期事件）</p>
<p>主要的生命周期函数分类：<br>    1.创建期间的生命周期函数：<br>        beforeCreate :实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性<br>        created：实例已经在内存中创建OK，此时data和methods已经创建OK，此时还没有开始编译模板<br>        beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中<br>        mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</p>
<p>​    2.运行期间的生命周期函数：<br>​        beforeUpdate：状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的。因为此时还没有开始重新渲染DOM节点<br>​        updated：实例更新完毕之后调用此函数。此时data中的状态值和界面上显示的数据都已经完成了更新，界面已经被重新渲染好了!</p>
<p>​    3.销毁期间的生命周期函数：<br>​        beforeDestroy：实例销毁之前调用。在这一步,实例仍然完全可用。<br>​        destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p>​        注意：组件销毁生命周期只有切换路由的时候或者关闭该组件的时候起作用，跟浏览器关闭不关闭，没有关系。</p>
<p><img src="/2021/07/04/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="生命周期详解"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>点击按钮调用接口模板</title>
    <url>/2021/07/04/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">comfirmEdit</span>(<span class="params">formName</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.editAvoidAreaModelForm);</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">      <span class="built_in">this</span>.$refs[formName].validate(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">this</span>.$confirm(<span class="string">&quot;确认修改该属性吗?&quot;</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">confirmButtonText</span>: <span class="string">&quot;确定&quot;</span>,</span><br><span class="line">            <span class="attr">cancelButtonText</span>: <span class="string">&quot;取消&quot;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">          &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            request(&#123;</span><br><span class="line">              <span class="attr">url</span>: <span class="string">&quot;/xxxxxxxxx/xxxxxxxxxxxxxx/xxxxxxxxxxxx&quot;</span>,</span><br><span class="line">              <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">              <span class="attr">data</span>: data,</span><br><span class="line">            &#125;)</span><br><span class="line">              .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.data.code == <span class="number">200</span>) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.$notify(&#123;</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">                    <span class="attr">message</span>: <span class="string">&quot;修改成功！&quot;</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">                  &#125;);</span><br><span class="line">                  <span class="built_in">this</span>.editAvoidVisible = <span class="literal">false</span>;</span><br><span class="line">                  <span class="built_in">this</span>.avoidModelInfo = [];</span><br><span class="line">                  <span class="built_in">this</span>.getAvoidArea();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res.data.code == <span class="number">500</span>) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.$notify.error(&#123;</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&quot;错误&quot;</span>,</span><br><span class="line">                    <span class="attr">message</span>: <span class="string">&quot;修改失败!&quot;</span>,</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">              &#125;)</span><br><span class="line">              .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>BERT简单理解</title>
    <url>/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p><strong>结构：</strong>采用了 Transformer 的 Encoder 结构，但是模型结构比 Transformer 要深。Transformer Encoder 包含 6 个 Encoder block，BERT-base 模型包含 12 个 Encoder block，BERT-large 包含 24 个 Encoder block。</p>
<p><strong>训练：</strong>训练主要分为两个阶段：预训练阶段和 Fine-tuning 阶段。预训练阶段与 Word2Vec，ELMo 等类似，是在大型数据集上根据一些预训练任务训练得到。Fine-tuning 阶段是后续用于一些下游任务的时候进行微调，例如文本分类，词性标注，问答系统等，BERT 无需调整结构就可以在不同的任务上进行微调。</p>
<p><strong>预训练任务1：</strong>BERT 的第一个预训练任务是 <strong>Masked LM</strong>，在句子中随机遮盖一部分单词，然后同时利用上下文的信息预测遮盖的单词，这样可以更好地根据全文理解单词的意思。Masked LM 是 BERT 的重点，和 biLSTM 预测方法是有区别的，后续会讲到。</p>
<p><strong>预训练任务2：</strong>BERT 的第二个预训练任务是 **Next Sentence Prediction (NSP)**，下一句预测任务，这个任务主要是让模型能够更好地理解句子间的关系。</p>
<h2 id="2-BERT结构"><a href="#2-BERT结构" class="headerlink" title="2.BERT结构"></a>2.BERT结构</h2><p><img src="/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/1.png" alt="BERT结构"></p>
<p>上图是 BERT 的结构图，左侧的图表示了预训练的过程，右边的图是对于具体任务的微调过程。</p>
<h3 id="2-1-BERT-的输入"><a href="#2-1-BERT-的输入" class="headerlink" title="2.1 BERT 的输入"></a>2.1 BERT 的输入</h3><p>BERT 的输入可以包含一个句子对 (句子 A 和句子 B)，也可以是单个句子。同时 BERT 增加了一些有特殊作用的标志位：</p>
<ul>
<li>[CLS] 标志放在第一个句子的首位，经过 BERT 得到的的表征向量 <strong>C</strong> 可以用于后续的分类任务。</li>
<li>[SEP] 标志用于分开两个输入句子，例如输入句子 A 和 B，要在句子 A，B 后面增加 [SEP] 标志。</li>
<li>[MASK] 标志用于遮盖句子中的一些单词，将单词用 [MASK] 遮盖之后，再利用 BERT 输出的 [MASK] 向量预测单词是什么。</li>
</ul>
<p>例如给定两个句子 “my dog is cute” 和 “he likes palying” 作为输入样本，BERT 会转为 “[CLS] my dog is cute [SEP] he likes play ##ing [SEP]”。BERT 里面用了 WordPiece 方法，会将单词拆成子词单元 (SubWord)，所以有的词会拆出词根，例如 “palying” 会变成 “paly” + “##ing”。</p>
<p>BERT 得到要输入的句子后，要将句子的单词转成 Embedding，Embedding 用 <strong>E</strong>表示。与 Transformer 不同，BERT 的输入 Embedding 由三个部分相加得到：Token Embedding，Segment Embedding，Position Embedding。</p>
<p><img src="/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/2.png" alt="BERT的输入"></p>
<p><strong>Token Embedding：</strong>单词的 Embedding，例如 [CLS] dog 等，通过训练学习得到。</p>
<p><strong>Segment Embedding：</strong>用于区分每一个单词属于句子 A 还是句子 B，如果只输入一个句子就只使用 <strong>E</strong>A，通过训练学习得到。</p>
<p><strong>Position Embedding：</strong>编码单词出现的位置，与 Transformer 使用固定的公式计算不同，BERT 的 Position Embedding 也是通过学习得到的，在 BERT 中，假设句子最长为 512。</p>
<h3 id="2-2-BERT-预训练"><a href="#2-2-BERT-预训练" class="headerlink" title="2.2 BERT 预训练"></a>2.2 BERT 预训练</h3><p>BERT 输入句子中单词的 Embedding 之后，通过预训练方式训练模型，预训练有两个任务。</p>
<p>第一个是 Masked LM，在句子中随机用 [MASK] 替换一部分单词，然后将句子传入 BERT 中编码每一个单词的信息，最终用 [MASK] 的编码信息 <strong>T</strong>[MASK] 预测该位置的正确单词。</p>
<p>第二个是下一句预测，将句子 A 和 B 输入 BERT，预测 B 是否 A 的下一句，使用 [CLS] 的编码信息 <strong>C</strong>进行预测。</p>
<p>BERT 预训练的过程可以用下图来表示。</p>
<p><img src="/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/3.png" alt="BERT预训练过程"></p>
<h3 id="2-3-BERT-用于具体-NLP-任务"><a href="#2-3-BERT-用于具体-NLP-任务" class="headerlink" title="2.3 BERT 用于具体 NLP 任务"></a>2.3 BERT 用于具体 NLP 任务</h3><p>预训练得到的 BERT 模型可以在后续用于具体 NLP 任务的时候进行微调 (<strong>Fine-tuning 阶段</strong>)，BERT 模型可以适用于多种不同的 NLP 任务，如下图所示。</p>
<p><img src="/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/4.png" alt="BERT用于不同任务"></p>
<p><strong>一对句子的分类任务：</strong>例如自然语言推断 (MNLI)，句子语义等价判断 (QQP) 等，如上图 (a) 所示，需要将两个句子传入 BERT，然后使用 [CLS] 的输出值 <strong>C</strong>进行句子对分类。</p>
<p><strong>单个句子分类任务：</strong>例如句子情感分析 (SST-2)，判断句子语法是否可以接受 (CoLA) 等，如上图 (b) 所示，只需要输入一个句子，无需使用 [SEP] 标志，然后也是用 [CLS] 的输出值 <strong>C</strong>进行分类。</p>
<p><strong>问答任务：</strong>如 SQuAD v1.1 数据集，样本是语句对 (Question, Paragraph)，Question 表示问题，Paragraph 是一段来自 Wikipedia 的文本，Paragraph 包含了问题的答案。而训练的目标是在 Paragraph 找出答案的起始位置 (Start，End)。如上图 (c) 所示，将 Question 和 Paragraph 传入 BERT，然后 BERT 根据 Paragraph 所有单词的输出预测 Start 和 End 的位置。</p>
<p><strong>单个句子标注任务：</strong>例如命名实体识别 (NER)，输入单个句子，然后根据 BERT 对于每个单词的输出 <strong>T</strong>预测这个单词的类别，是属于 Person，Organization，Location，Miscellaneous 还是 Other (非命名实体)。</p>
<h2 id="3-预训练任务"><a href="#3-预训练任务" class="headerlink" title="3. 预训练任务"></a>3. 预训练任务</h2><p>预训练部分是 BERT 的重点，接下来了解 BERT 预训练的细节。BERT 包括两个预训练任务 <strong>Masked LM</strong>和 <strong>下一句预测</strong>。</p>
<h3 id="3-1-Masked-LM"><a href="#3-1-Masked-LM" class="headerlink" title="3.1 Masked LM"></a>3.1 Masked LM</h3><p>我们先回顾一下以往语言模型的预训练方法，使用句子 “我/喜欢/学习/自然/语言/处理” 为例。在训练语言模型的时候通常需要进行一些 <strong>Mask</strong>操作，防止信息泄露问题，信息泄露指在预测单词 “自然” 的时候，提前得知 “自然” 的信息。后面会讲到 Transformer Encoder 信息泄露的原因。</p>
<p><strong>Word2Vec 的 CBOW：</strong>通过单词 i 的上文和下文信息预测单词 i，但是采用的是词袋模型，不知道单词的顺序信息。例如预测单词 “自然” 的时候，会同时采用上文 “我/喜欢/学习” 和下文 “语言/处理” 进行预测。CBOW 在训练时是相当于把 “自然” 这个单词 Mask 的。</p>
<p><strong>ELMo：</strong>ELMo 在训练的时候使用 biLSTM，预测 “自然” 的时候，前向 LSTM 会 Mask “自然” 之后的所有单词，使用上文 “我/喜欢/学习” 预测；后向 LSTM 会 Mask “自然” 之前的单词，使用下文 “语言/处理” 进行预测。然后再将前向 LSTM 和后向 LSTM 的输出拼接在一起，因此 ELMo 是将上下文信息分隔开进行预测的，而不是同时利用上下文信息进行预测。</p>
<p><strong>OpenAI GPT：</strong>OpenAI GPT 是另外一种使用 Transformer 训练语言模型的算法，但是 OpenAI GPT 使用的是 Transformer 的 Decoder，是一种单向的结构。预测 “自然” 的时候只使用上文 “我/喜欢/学习”，Decoder 中包含了 Mask 操作，将当前预测词之后的单词都 Mask。</p>
<p>下图显示了 BERT 和 ELMo、OpenAI GPT 的区别。</p>
<p><img src="/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/5.png" alt="ELMo和OpenAI GPT"></p>
<p>BERT 的作者认为在预测单词时，要同时利用单词 left (上文) 和 right (下文) 信息才能最好地预测。将 ELMo 这种分别进行 left-to-right 和 right-to-left 的模型称为 **shallow bidirectional model (浅层双向模型)**，BERT 希望在 Transformer Encoder 结构上训练出一种深度双向模型 <strong>deep bidirectional model</strong>，因此提出了 Mask LM 这种方法进行训练。</p>
<p><strong>Mask LM 是用于防止信息泄露的</strong>，例如预测单词 “自然” 的时候，如果不把输入部分的 “自然” Mask 掉，则预测输出的地方是可以直接获得 “自然” 的信息。</p>
<p><img src="/2021/07/01/BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/6.jpeg" alt="BERT的Masked LM"></p>
<p>BERT 在训练时只预测 [Mask] 位置的单词，这样就可以同时利用上下文信息。但是在后续使用的时候，句子中并不会出现 [Mask] 的单词，这样会影响模型的性能。因此在训练时采用如下策略，随机选择句子中 15% 的单词进行 Mask，在选择为 Mask 的单词中，有 80% 真的使用 [Mask] 进行替换，10% 不进行替换，剩下 10% 使用一个随机单词替换。</p>
<p>例如句子 “my dog is hairy”，选择了单词 “hairy” 进行 Mask，则：</p>
<p>80% 的概率，将句子 “my dog is hairy” 转换为句子 “my dog is [Mask]”。10% 的概率，保持句子为 “my dog is hairy” 不变。10% 的概率，将单词 “hairy” 替换成另一个随机词，例如 “apple”。将句子 “my dog is hairy” 转换为句子 “my dog is apple”。以上是 BERT 的第一个预训练任务 Masked LM。</p>
<h3 id="3-2-下一句预测"><a href="#3-2-下一句预测" class="headerlink" title="3.2 下一句预测"></a>3.2 下一句预测</h3><p>BERT 的第二个预训练任务是 **Next Sentence Prediction (NSP)**，即下一句预测，给定两个句子 A 和 B，要预测句子 B 是否是句子 A 的下一个句子。</p>
<p>BERT 使用这一预训练任务的主要原因是，很多下游任务，例如问答系统 (QA)，自然语言推断 (NLI) 都需要模型能够理解两个句子之间的关系，但是通过训练语言模型达不到这个目的。</p>
<p>BERT 在进行训练的时候，有 50% 的概率会选择相连的两个句子 A B，有 50% 的概率会选择不相连得到两个句子 A B，然后通过 [CLS] 标志位的输出 <strong>C</strong>预测句子 A 的下一句是不是句子 B。</p>
<ul>
<li>输入 = [CLS] 我 喜欢 玩 [Mask] 联盟 [SEP] 我 最 擅长 的 [Mask] 是 亚索 [SEP]类别 = B 是 A 的下一句</li>
<li>输入 = [CLS] 我 喜欢 玩 [Mask] 联盟 [SEP] 今天 天气 很 [Mask] [SEP]类别 = B 不是 A 的下一句</li>
</ul>
<h2 id="4-BERT-总结"><a href="#4-BERT-总结" class="headerlink" title="4. BERT 总结"></a>4. BERT 总结</h2><p>因为 BERT 预训练时候采用了 Masked LM，每个 batch 只会训练 15% 的单词，因此需要更多的预训练步骤。ELMo 之类的顺序模型，会对每一个单词都进行预测。</p>
<p>BERT 使用了 Transformer 的 Encoder 和 Masked LM 预训练方法，因此可以进行双向预测；而 OpenAI GPT 使用了 Transformer 的 Decoder 结构，利用了 Decoder 中的 Mask，只能顺序预测。</p>
<p>参考：<a href="https://baijiahao.baidu.com/s?id=1651912822853865814&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1651912822853865814&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>预训练与微调</title>
    <url>/2021/07/01/%E9%A2%84%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/</url>
    <content><![CDATA[<p>预训练（pre-training/trained）和微调（fine tuning）这两个词经常在论文中见到，今天主要按以下两点来说明。</p>
<ul>
<li>什么是预训练和微调？</li>
<li>它俩有什么作用?</li>
</ul>
<h3 id="什么是预训练和微调"><a href="#什么是预训练和微调" class="headerlink" title="什么是预训练和微调"></a>什么是预训练和微调</h3><ul>
<li><p>你需要搭建一个网络模型来完成一个特定的图像分类的任务。首先，你需要随机初始化参数，然后开始训练网络，不断调整直到网络的损失越来越小。在训练的过程中，一开始初始化的参数会不断变化。当你觉得结果很满意的时候，你就可以将训练模型的参数保存下来，以便训练好的模型可以在下次执行类似任务时获得较好的结果。这个过程就是 pre-training。</p>
</li>
<li><p>之后，你又接收到一个类似的图像分类的任务。这时候，你可以直接使用之前保存下来的模型的参数来作为这一任务的初始化参数，然后在训练的过程中，依据结果不断进行一些修改。这时候，你使用的就是一个 pre-trained 模型，而过程就是 fine tuning。</p>
</li>
</ul>
<p><strong>所以，预训练 就是指预先训练的一个模型或者指预先训练模型的过程；微调 就是指将预训练过的模型作用于自己的数据集，并使参数适应自己数据集的过程。</strong></p>
<h3 id="预训练和微调的作用"><a href="#预训练和微调的作用" class="headerlink" title="预训练和微调的作用"></a>预训练和微调的作用</h3><p>在 CNN 领域中，实际上，很少人自己从头训练一个 CNN 网络。主要原因是自己很小的概率会拥有足够大的数据集，基本是几百或者几千张，不像 ImageNet 有 120 万张图片这样的规模。拥有的数据集不够大，而又想使用很好的模型的话，很容易会造成过拟合。</p>
<p>所以，一般的操作都是在一个大型的数据集上（ImageNet）训练一个模型，然后使用该模型作为类似任务的初始化或者特征提取器。比如 VGG，Inception 等模型都提供了自己的训练参数，以便人们可以拿来微调。这样既节省了时间和计算资源，又能很快的达到较好的效果。</p>
<p>参考：<a href="https://www.jianshu.com/p/330ee6e7ceda">https://www.jianshu.com/p/330ee6e7ceda</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习文档</title>
    <url>/2021/07/01/Python%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一键加载 Lcqmc 的训练集、验证集</span></span><br><span class="line">train_ds, dev_ds = load_dataset(<span class="string">&quot;lcqmc&quot;</span>, splits=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;dev&quot;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, example <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_ds):</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encoded_inputs = tokenizer(</span><br><span class="line">       text=query, text_pair=title, max_seq_len=max_seq_length)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label = np.array([example[<span class="string">&quot;label&quot;</span>]], dtype=<span class="string">&quot;int64&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue切换组件</title>
    <url>/2021/06/23/Vue%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="一、使用flag标识符结合v-if和v-else切换组件"><a href="#一、使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="一、使用flag标识符结合v-if和v-else切换组件"></a>一、使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h1><p>此方法主要是利用一个标记变量来控制组建的显示与否，if与else语句控制只显示一个组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;search()&quot;\&gt;&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">&lt;Information v-if=&quot;flag&quot;/&gt;</span><br><span class="line">&lt;IndexInfo v-else/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import Information from &quot;./components/Information.vue&quot;;</span><br><span class="line">import IndexInfo from &quot;./components/IndexInfo.vue&quot;;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     flag: true</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">search()&#123;</span><br><span class="line">     this.flag = !this.flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、使用-is属性来切换不同的子组件"><a href="#二、使用-is属性来切换不同的子组件" class="headerlink" title="二、使用:is属性来切换不同的子组件"></a>二、使用<code>:is</code>属性来切换不同的子组件</h1><p>这种方法主要利用组件名字来判断显示哪个组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;search()&quot;&gt;&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import Information from &quot;./components/Information.vue&quot;;</span><br><span class="line">import IndexInfo from &quot;./components/IndexInfo.vue&quot;;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      comName: &#x27;IndexInfo&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> search()&#123;</span><br><span class="line">      this.comName = &#x27;Information&#x27;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack视频教程</title>
    <url>/2021/06/23/Webpack%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、Webpack-简介"><a href="#一、Webpack-简介" class="headerlink" title="一、Webpack 简介"></a>一、Webpack 简介</h1><h2 id="1-1-webpack-是什么"><a href="#1-1-webpack-是什么" class="headerlink" title="1.1 webpack 是什么"></a>1.1 webpack 是什么</h2><p>webpack 是一种<strong>前端资源构建工具</strong>，一个静态模块打包器(module bundler)。</p>
<p>在webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。<br>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</p>
<h2 id="1-2-webpack-五个核心概念"><a href="#1-2-webpack-五个核心概念" class="headerlink" title="1.2 webpack 五个核心概念"></a>1.2 webpack 五个核心概念</h2><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>入口(Entry)：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出(Output)：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</p>
<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p>Loader：让 webpack 能够去处理那些非 JS 的文件，比如样式文件、图片文(webpack 自身只理解JS)</p>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>插件(Plugins)：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</p>
<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>模式(Mode)：指示 webpack 使用相应模式的配置。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>development</td>
<td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。</td>
<td>能让代码本地调试运行的环境</td>
</tr>
<tr>
<td>production</td>
<td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="二、Webpack-初体验"><a href="#二、Webpack-初体验" class="headerlink" title="二、Webpack 初体验"></a>二、Webpack 初体验</h1><h2 id="2-1-初始化配置"><a href="#2-1-初始化配置" class="headerlink" title="2.1 初始化配置"></a>2.1 初始化配置</h2><ol>
<li><p>初始化 package.json：npm init</p>
</li>
<li><p>下载安装webpack：(webpack4以上的版本需要全局/本地都安装webpack-cli)</p>
<p>全局安装：cnpm i webpack webpack-cli -g</p>
<p>本地安装：cnpm i webpack webpack-cli -D</p>
</li>
</ol>
<h2 id="2-2-编译打包应用"><a href="#2-2-编译打包应用" class="headerlink" title="2.2 编译打包应用"></a>2.2 编译打包应用</h2><p>创建 src 下的 js 等文件后，不需要配置 webpack.config.js 文件，在命令行就可以编译打包。</p>
<p>指令：</p>
<ul>
<li><p>开发环境：webpack ./src/index.js -o ./build/built.js –mode=development</p>
<p>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境，是开发环境</p>
</li>
<li><p>生产环境：webpack ./src/index.js -o ./build/built.js –mode=production</p>
<p>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境，是生产环境</p>
</li>
</ul>
<p>结论：</p>
<ol>
<li>webpack 本身能处理 js/json 资源，不能处理 css/img 等其他资源</li>
<li>生产环境和开发环境将 ES6 模块化编译成浏览器能识别的模块化，但是不能处理 ES6 的基本语法转化为 ES5（需要借助 loader）</li>
<li>生产环境比开发环境多一个压缩 js 代码</li>
</ol>
<h1 id="三、Webpack-开发环境的基本配置"><a href="#三、Webpack-开发环境的基本配置" class="headerlink" title="三、Webpack 开发环境的基本配置"></a>三、Webpack 开发环境的基本配置</h1><p>webpack.config.js 是 webpack 的配置文件。</p>
<p>作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）</p>
<p>所有构建工具都是基于 nodejs 平台运行的，模块化默认采用 commonjs。</p>
<p>开发环境配置主要是为了能让代码运行。主要考虑以下几个方面：</p>
<ul>
<li>打包样式资源</li>
<li>打包 html 资源</li>
<li>打包图片资源</li>
<li>打包其他资源</li>
<li>devServer</li>
</ul>
<p>下面是一个简单的开发环境webpack.confg.js配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// resolve用来拼接绝对路径的方法</span><br><span class="line">const &#123; resolve &#125; = require(&#x27;path&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) // 引用plugin</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // webpack配置</span><br><span class="line">  entry: &#x27;./src/js/index.js&#x27;, // 入口起点</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 输出</span><br><span class="line">    // 输出文件名</span><br><span class="line">    filename: &#x27;js/build.js&#x27;,</span><br><span class="line">    // __dirname是nodejs的变量，代表当前文件的目录绝对路径</span><br><span class="line">    path: resolve(__dirname, &#x27;build&#x27;), // 输出路径，所有资源打包都会输出到这个文件夹下</span><br><span class="line">  &#125;,</span><br><span class="line">  // loader配置</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // 详细的loader配置</span><br><span class="line">      // 不同文件必须配置不同loader处理</span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配哪些文件</span><br><span class="line">        test: /\.less$/,</span><br><span class="line">        // 使用哪些loader进行处理</span><br><span class="line">        use: [</span><br><span class="line">          // use数组中loader执行顺序：从右到左，从下到上，依次执行(先执行css-loader)</span><br><span class="line">          // style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效</span><br><span class="line">          &#x27;style-loader&#x27;,</span><br><span class="line">          // css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串</span><br><span class="line">          &#x27;css-loader&#x27;,</span><br><span class="line">          // less-loader：将less文件编译成css文件，需要下载less-loader和less</span><br><span class="line">          &#x27;less-loader&#x27;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // url-loader：处理图片资源，问题：默认处理不了html中的img图片</span><br><span class="line">        test: /\.(jpg|png|gif)$/,</span><br><span class="line">        // 需要下载 url-loader file-loader</span><br><span class="line">        loader: &#x27;url-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // 图片大小小于8kb，就会被base64处理，优点：减少请求数量（减轻服务器压力），缺点：图片体积会更大（文件请求速度更慢）</span><br><span class="line">          // base64在客户端本地解码所以会减少服务器压力，如果图片过大还采用base64编码会导致cpu调用率上升，网页加载时变卡</span><br><span class="line">          limit: 8 * 1024,</span><br><span class="line">          // 给图片重命名，[hash:10]：取图片的hash的前10位，[ext]：取文件原来扩展名</span><br><span class="line">          name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是conmonjs，解析时会出问题：[object Module]</span><br><span class="line">          // 解决：关闭url-loader的es6模块化，使用commonjs解析</span><br><span class="line">          esModule: false,</span><br><span class="line">          outputPath: &#x27;imgs&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span><br><span class="line">        loader: &#x27;html-loader&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      // 打包其他资源(除了html/js/css资源以外的资源)</span><br><span class="line">      &#123;</span><br><span class="line">        // 排除html|js|css|less|jpg|png|gif文件</span><br><span class="line">        exclude: /\.(html|js|css|less|jpg|png|gif)/,</span><br><span class="line">        // file-loader：处理其他文件</span><br><span class="line">        loader: &#x27;file-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">          outputPath: &#x27;media&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  // plugin的配置</span><br><span class="line">  plugins: [</span><br><span class="line">    // html-webpack-plugin：默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）</span><br><span class="line">    // 需要有结构的HTML文件可以加一个template</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      // 复制这个./src/index.html文件，并自动引入打包输出的所有资源（JS/CSS）</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  // 模式</span><br><span class="line">  mode: &#x27;development&#x27;, // 开发模式</span><br><span class="line">  // 开发服务器 devServer：用来自动化，不用每次修改后都重新输入webpack打包一遍（自动编译，自动打开浏览器，自动刷新浏览器）</span><br><span class="line">  // 特点：只会在内存中编译打包，不会有任何输出（不会像之前那样在外面看到打包输出的build包，而是在内存中，关闭后会自动删除）</span><br><span class="line">  // 启动devServer指令为：npx webpack-dev-server</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // 项目构建后路径</span><br><span class="line">    contentBase: resolve(__dirname, &#x27;build&#x27;),</span><br><span class="line">    // 启动gzip压缩</span><br><span class="line">    compress: true,</span><br><span class="line">    // 端口号</span><br><span class="line">    port: 3000,</span><br><span class="line">    // 自动打开浏览器</span><br><span class="line">    open: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，大部分配置都在注释中给出解释。</p>
<ul>
<li><p>运行项目的两个指令：<br>webpack 会将打包结果输出出去（build文件夹）<br>npx webpack-dev-server 只会在内存中编译打包，没有输出</p>
</li>
<li><p>loader 和 plugin 的不同：（plugin 一定要先引入才能使用）</p>
<p>loader：1. 下载 2. 使用（配置 loader）</p>
<p>plugins：1.下载 2. 引入 3. 使用</p>
</li>
</ul>
<h1 id="四、Webpack-生产环境的基本配置"><a href="#四、Webpack-生产环境的基本配置" class="headerlink" title="四、Webpack 生产环境的基本配置"></a>四、Webpack 生产环境的基本配置</h1><p>而生产环境的配置需要考虑以下几个方面：</p>
<ul>
<li>提取 css 成单独文件</li>
<li>css 兼容性处理</li>
<li>压缩 css</li>
<li>js 语法检查</li>
<li>js 兼容性处理</li>
<li>js 压缩</li>
<li>html 压缩</li>
</ul>
<p>下面是一个基本的生产环境下的webpack.config.js配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; = require(&#x27;path&#x27;)</span><br><span class="line">const MiniCssExtractorPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line">const OptimiziCssAssetsWebpackPlugin = require(&#x27;optimizi-css-assets-webpack-plugin&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">// 定义node.js的环境变量，决定使用browserslist的哪个环境</span><br><span class="line">process.env.NODE_ENV = &#x27;production&#x27;</span><br><span class="line"></span><br><span class="line">// 复用loader的写法</span><br><span class="line">const commonCssLoader = [</span><br><span class="line">  // 这个loader取代style-loader。作用：提取js中的css成单独文件然后通过link加载</span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  // css-loader：将css文件整合到js文件中</span><br><span class="line">  // 经过css-loader处理后，样式文件是在js文件中的</span><br><span class="line">  // 问题：1.js文件体积会很大2.需要先加载js再动态创建style标签，样式渲染速度就慢，会出现闪屏现象</span><br><span class="line">  // 解决：用MiniCssExtractPlugin.loader替代style-loader</span><br><span class="line">  &#x27;css-loader&#x27;,</span><br><span class="line">  /*</span><br><span class="line">    postcss-loader：css兼容性处理：postcss --&gt; 需要安装：postcss-loader postcss-preset-env</span><br><span class="line">    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式</span><br><span class="line">    在package.json中定义browserslist：</span><br><span class="line">    &quot;browserslist&quot;: &#123;</span><br><span class="line">      // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span><br><span class="line">      &quot;development&quot;: [ // 只需要可以运行即可</span><br><span class="line">        &quot;last 1 chrome version&quot;,</span><br><span class="line">        &quot;last 1 firefox version&quot;,</span><br><span class="line">        &quot;last 1 safari version&quot;</span><br><span class="line">      ],</span><br><span class="line">      // 生产环境。默认是生产环境</span><br><span class="line">      &quot;production&quot;: [ // 需要满足绝大多数浏览器的兼容</span><br><span class="line">        &quot;&gt;0.2%&quot;,</span><br><span class="line">        &quot;not dead&quot;,</span><br><span class="line">        &quot;not op_mini all&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  */</span><br><span class="line">  &#123;</span><br><span class="line">    loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: &#x27;postcss&#x27;, // 基本写法</span><br><span class="line">      plugins: () =&gt; [</span><br><span class="line">        // postcss的插件</span><br><span class="line">        require(&#x27;postcss-preset-env&#x27;)(),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/js/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;js/built.js&#x27;,</span><br><span class="line">    path: resolve(__dirname, &#x27;build&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [...commonCssLoader],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.less$/,</span><br><span class="line">        use: [...commonCssLoader, &#x27;less-loader&#x27;],</span><br><span class="line">      &#125;,</span><br><span class="line">      /*</span><br><span class="line">        正常来讲，一个文件只能被一个loader处理</span><br><span class="line">        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序</span><br><span class="line">        先执行eslint再执行babel（用enforce）</span><br><span class="line">      */</span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">          js的语法检查： 需要下载 eslint-loader eslint</span><br><span class="line">          注意：只检查自己写的源代码，第三方的库是不用检查的</span><br><span class="line">          airbnb(一个流行的js风格) --&gt; 需要下载 eslint-config-airbnb-base eslint-plugin-import</span><br><span class="line">          设置检查规则：</span><br><span class="line">            package.json中eslintConfig中设置</span><br><span class="line">              &quot;eslintConfig&quot;: &#123;</span><br><span class="line">                &quot;extends&quot;: &quot;airbnb-base&quot;， // 继承airbnb的风格规范</span><br><span class="line">                &quot;env&quot;: &#123;</span><br><span class="line">                  &quot;browser&quot;: true // 可以使用浏览器中的全局变量(使用window不会报错)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">        */</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /node_modules/, // 忽略node_modules</span><br><span class="line">        enforce: &#x27;pre&#x27;, // 优先执行</span><br><span class="line">        loader: &#x27;eslint-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // 自动修复</span><br><span class="line">          fix: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      /*</span><br><span class="line">        js兼容性处理：需要下载 babel-loader @babel/core</span><br><span class="line">          1. 基本js兼容性处理 --&gt; @babel/preset-env</span><br><span class="line">            问题：只能转换基本语法，如promise高级语法不能转换</span><br><span class="line">          2. 全部js兼容性处理 --&gt; @babel/polyfill</span><br><span class="line">            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了</span><br><span class="line">          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js</span><br><span class="line">      */</span><br><span class="line">      &#123;</span><br><span class="line">        // 第三种方式：按需加载</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // 预设：指示babel做怎样的兼容性处理</span><br><span class="line">          presets: [</span><br><span class="line">            &#x27;@babel/preset-env&#x27;, // 基本预设</span><br><span class="line">            &#123;</span><br><span class="line">              useBuiltIns: &#x27;usage&#x27;, //按需加载</span><br><span class="line">              corejs: &#123; version: 3 &#125;, // 指定core-js版本</span><br><span class="line">              targets: &#123; // 指定兼容到什么版本的浏览器</span><br><span class="line">                chrome: &#x27;60&#x27;,</span><br><span class="line">                firefox: &#x27;50&#x27;,</span><br><span class="line">                ie: &#x27;9&#x27;,</span><br><span class="line">                safari: &#x27;10&#x27;,</span><br><span class="line">                edge: &#x27;17&#x27;</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 图片处理</span><br><span class="line">        test: /\.(jpg|png|gif)/,</span><br><span class="line">        loader: &#x27;url-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 8 * 1024,</span><br><span class="line">          name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">          outputPath: &#x27;imgs&#x27;,</span><br><span class="line">          esModule: false, // 关闭url-loader默认使用的es6模块化解析</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      // html中的图片处理</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        loader: &#x27;html-loader&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      // 处理其他文件</span><br><span class="line">      &#123;</span><br><span class="line">        exclude: /\.(js|css|less|html|jpg|png|gif)/,</span><br><span class="line">        loader: &#x27;file-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          outputPath: &#x27;media&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      // 对输出的css文件进行重命名</span><br><span class="line">      filename: &#x27;css/built.css&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">    // 压缩css</span><br><span class="line">    new OptimiziCssAssetsWebpackPlugin(),</span><br><span class="line">    // HtmlWebpackPlugin：html文件的打包和压缩处理</span><br><span class="line">    // 通过这个插件会自动将单独打包的样式文件通过link标签引入</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">      // 压缩html代码</span><br><span class="line">      minify: &#123;</span><br><span class="line">        // 移除空格</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        // 移除注释</span><br><span class="line">        removeComments: true,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  // 生产环境下会自动压缩js代码</span><br><span class="line">  mode: &#x27;production&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、Webpack-优化配置"><a href="#五、Webpack-优化配置" class="headerlink" title="五、Webpack 优化配置"></a>五、Webpack 优化配置</h1><h2 id="5-1-开发环境性能优化"><a href="#5-1-开发环境性能优化" class="headerlink" title="5.1 开发环境性能优化"></a>5.1 开发环境性能优化</h2><h3 id="5-1-1-HMR（模块热替换）"><a href="#5-1-1-HMR（模块热替换）" class="headerlink" title="5.1.1 HMR（模块热替换）"></a>5.1.1 HMR（模块热替换）</h3><p>HMR: hot module replacement 热模块替换 / 模块热替换</p>
<p>作用：一个模块发生变化，只会重新打包构建这一个模块（而不是打包所有模块） ，极大提升构建速度</p>
<p>代码：只需要在 devServer 中设置 hot 为 true，就会自动开启HMR功能（只能在开发模式下使用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: resolve(__dirname, &#x27;build&#x27;),</span><br><span class="line">  compress: true,</span><br><span class="line">  port: 3000,</span><br><span class="line">  open: true,</span><br><span class="line">  // 开启HMR功能</span><br><span class="line">  // 当修改了webpack配置，新配置要想生效，必须重启webpack服务</span><br><span class="line">  hot: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种文件实现热模块替换的情况：</p>
<ul>
<li><p>样式文件：可以使用HMR功能，因为开发环境下使用的 style-loader 内部默认实现了热模块替换功能</p>
</li>
<li><p>js 文件：默认不能使用HMR功能（修改一个 js 模块所有 js 模块都会刷新）</p>
<p>–&gt; 实现 HMR 需要修改 js 代码（添加支持 HMR 功能的代码）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 绑定</span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">  // 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span><br><span class="line">  module.hot.accept(&#x27;./print.js&#x27;, function() &#123;</span><br><span class="line">    // 方法会监听 print.js 文件的变化，一旦发生变化，只有这个模块会重新打包构建，其他模块不会。</span><br><span class="line">    // 会执行后面的回调函数</span><br><span class="line">    print();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件。</p>
</li>
<li><p>html 文件: 默认不能使用 HMR 功能（html 不用做 HMR 功能，因为只有一个 html 文件，不需要再优化）</p>
<p>使用 HMR 会导致问题：html 文件不能热更新了（不会自动打包构建）</p>
<p>解决：修改 entry 入口，将 html 文件引入（这样 html 修改整体刷新）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: [&#x27;./src/js/index.js&#x27;, &#x27;./src/index.html&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-source-map"><a href="#5-1-2-source-map" class="headerlink" title="5.1.2 source-map"></a>5.1.2 source-map</h3><p>source-map：一种提供<strong>源代码到构建后代码的映射</strong>的技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</p>
<p>参数：<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devtool: &#x27;eval-source-map&#x27;</span><br></pre></td></tr></table></figure>

<p>可选方案：[生成source-map的位置|给出的错误代码信息]</p>
<ul>
<li>source-map：外部，错误代码准确信息 和 源代码的错误位置</li>
<li>inline-source-map：内联，只生成一个内联 source-map，错误代码准确信息 和 源代码的错误位置</li>
<li>hidden-source-map：外部，错误代码错误原因，但是没有错误位置（为了隐藏源代码），不能追踪源代码错误，只能提示到构建后代码的错误位置</li>
<li>eval-source-map：内联，每一个文件都生成对应的 source-map，都在 eval 中，错误代码准确信息 和 源代码的错误位</li>
<li>nosources-source-map：外部，错误代码准确信息，但是没有任何源代码信息（为了隐藏源代码）</li>
<li>cheap-source-map：外部，错误代码准确信息 和 源代码的错误位置，只能把错误精确到整行，忽略列</li>
<li>cheap-module-source-map：外部，错误代码准确信息 和 源代码的错误位置，module 会加入 loader 的 source-map</li>
</ul>
<p>内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</p>
<p>开发/生产环境可做的选择：</p>
<p><strong>开发环境</strong>：需要考虑速度快，调试更友好</p>
<ul>
<li>速度快( eval &gt; inline &gt; cheap &gt;… )<ol>
<li>eval-cheap-souce-map</li>
<li>eval-source-map</li>
</ol>
</li>
<li>调试更友好<ol>
<li>souce-map</li>
<li>cheap-module-souce-map</li>
<li>cheap-souce-map</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; eval-source-map（完整度高，内联速度快，vue和react脚手架默认使用这种） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）</strong></p>
<p><strong>生产环境</strong>：需要考虑源代码要不要隐藏，调试要不要更友好</p>
<ul>
<li>内联会让代码体积变大，所以在生产环境不用内联</li>
<li>隐藏源代码<ol>
<li>nosources-source-map 全部隐藏</li>
<li>hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）</strong></p>
<h2 id="5-2-生产环境性能优化"><a href="#5-2-生产环境性能优化" class="headerlink" title="5.2 生产环境性能优化"></a>5.2 生产环境性能优化</h2><h3 id="5-2-1-优化打包构建速度"><a href="#5-2-1-优化打包构建速度" class="headerlink" title="5.2.1 优化打包构建速度"></a>5.2.1 优化打包构建速度</h3><h4 id="5-2-1-1-oneOf"><a href="#5-2-1-1-oneOf" class="headerlink" title="5.2.1.1 oneOf"></a>5.2.1.1 oneOf</h4><p>oneOf：匹配到 loader 后就不再向后进行匹配，优化生产环境的打包构建速度</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      // js 语法检查</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // 优先执行</span><br><span class="line">      enforce: &#x27;pre&#x27;,</span><br><span class="line">      loader: &#x27;eslint-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        fix: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      // oneOf 优化生产环境的打包构建速度</span><br><span class="line">      // 以下loader只会匹配一个（匹配到了后就不会再往下匹配了）</span><br><span class="line">      // 注意：不能有两个配置处理同一种类型文件（所以把eslint-loader提取出去放外面）</span><br><span class="line">      oneOf: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.css$/,</span><br><span class="line">          use: [...commonCssLoader]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.less$/,</span><br><span class="line">          use: [...commonCssLoader, &#x27;less-loader&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // js 兼容性处理</span><br><span class="line">          test: /\.js$/,</span><br><span class="line">          exclude: /node_modules/,</span><br><span class="line">          loader: &#x27;babel-loader&#x27;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">              [</span><br><span class="line">                &#x27;@babel/preset-env&#x27;,</span><br><span class="line">                &#123;</span><br><span class="line">                  useBuiltIns: &#x27;usage&#x27;,</span><br><span class="line">                  corejs: &#123;version: 3&#125;,</span><br><span class="line">                  targets: &#123;</span><br><span class="line">                    chrome: &#x27;60&#x27;,</span><br><span class="line">                    firefox: &#x27;50&#x27;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.(jpg|png|gif)/,</span><br><span class="line">          loader: &#x27;url-loader&#x27;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: 8 * 1024,</span><br><span class="line">            name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">            outputPath: &#x27;imgs&#x27;,</span><br><span class="line">            esModule: false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.html$/,</span><br><span class="line">          loader: &#x27;html-loader&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          exclude: /\.(js|css|less|html|jpg|png|gif)/,</span><br><span class="line">          loader: &#x27;file-loader&#x27;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            outputPath: &#x27;media&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-2-babel-缓存"><a href="#5-2-1-2-babel-缓存" class="headerlink" title="5.2.1.2 babel 缓存"></a>5.2.1.2 babel 缓存</h4><p><strong>babel 缓存</strong>：类似 HMR，将 babel 处理后的资源缓存起来（哪里的 js 改变就更新哪里，其他 js 还是用之前缓存的资源），让第二次打包构建速度更快</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  loader: &#x27;babel-loader&#x27;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    presets: [</span><br><span class="line">      [</span><br><span class="line">        &#x27;@babel/preset-env&#x27;,</span><br><span class="line">        &#123;</span><br><span class="line">          useBuiltIns: &#x27;usage&#x27;,</span><br><span class="line">          corejs: &#123; version: 3 &#125;,</span><br><span class="line">          targets: &#123;</span><br><span class="line">            chrome: &#x27;60&#x27;,</span><br><span class="line">            firefox: &#x27;50&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    // 开启babel缓存</span><br><span class="line">    // 第二次构建时，会读取之前的缓存</span><br><span class="line">    cacheDirectory: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>文件资源缓存</strong></p>
<p>文件名不变，就不会重新请求，而是再次用之前缓存的资源</p>
<p>1.hash: 每次 wepack 打包时会生成一个唯一的 hash 值，不管文件有没有变化这个hash值都会变化，方法是在js和css原来的文件名和文件后缀中间加上’[hash:10]’。</p>
<p> 问题：重新打包，所有文件的 hsah 值都改变，会导致所有缓存失效。（可能只改动了一个文件）</p>
<p>2.chunkhash：根据 chunk 生成的 hash 值，方法是在js和css原来的文件名和文件后缀中间加上’[chunkhash:10]’。如果打包来源于同一个 chunk的 hash 值一样</p>
<p> 问题：js 和 css 来自同一个chunk，hash 值是一样的（因为 css-loader 会将 css 文件加载到 js 中，个人理解所有引入的文件都属于同一chunk）</p>
<p>3.contenthash: 根据文件的内容生成 hash 值，方法是在js和css原来的文件名和文件后缀中间加上’[contenthash:10]’。不同文件 hash 值一定不一样(文件内容修改，文件名里的 hash 才会改变)</p>
<p>修改 css 文件内容，打包后的 css 文件名 hash 值就改变，而 js 文件没有改变 hash 值就不变，这样 css 和 js 缓存就会分开判断要不要重新请求资源 –&gt; 让代码上线运行缓存更好使用</p>
<h4 id="5-2-1-3-多进程打包"><a href="#5-2-1-3-多进程打包" class="headerlink" title="5.2.1.3 多进程打包"></a>5.2.1.3 多进程打包</h4><p>多进程打包：某个任务消耗时间较长会卡顿，多进程可以同一时间干多件事，效率更高。</p>
<p>优点是提升打包速度，缺点是每个进程的开启和交流都会有开销（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  use: [</span><br><span class="line">    /* </span><br><span class="line">      thread-loader会对其后面的loader（这里是babel-loader）开启多进程打包。 </span><br><span class="line">      进程启动大概为600ms，进程通信也有开销。(启动的开销比较昂贵，不要滥用)</span><br><span class="line">      只有工作消耗时间比较长，才需要多进程打包</span><br><span class="line">    */</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;thread-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        workers: 2 // 进程2个</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;babel-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        presets: [</span><br><span class="line">          [</span><br><span class="line">            &#x27;@babel/preset-env&#x27;,</span><br><span class="line">            &#123;</span><br><span class="line">              useBuiltIns: &#x27;usage&#x27;,</span><br><span class="line">              corejs: &#123; version: 3 &#125;,</span><br><span class="line">              targets: &#123;</span><br><span class="line">                chrome: &#x27;60&#x27;,</span><br><span class="line">                firefox: &#x27;50&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ],</span><br><span class="line">        // 开启babel缓存</span><br><span class="line">        // 第二次构建时，会读取之前的缓存</span><br><span class="line">        cacheDirectory: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-4-externals"><a href="#5-2-1-4-externals" class="headerlink" title="5.2.1.4 externals"></a>5.2.1.4 externals</h4><p>externals：让某些库不打包，通过 cdn 引入</p>
<p>webpack.config.js 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  // 拒绝jQuery被打包进来(通过cdn引入，速度会快一些)</span><br><span class="line">  // 忽略的库名 -- npm包名</span><br><span class="line">  jquery: &#x27;jQuery&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 index.html 中通过 cdn 引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-5-dll"><a href="#5-2-1-5-dll" class="headerlink" title="5.2.1.5 dll"></a>5.2.1.5 dll</h4><p>dll：让某些库单独打包，后直接引入到 build 中。可以在 code split 分割出 node_modules 后再用 dll 更细的分割，优化代码运行的性能。</p>
<p>webpack.dll.js 配置：(将 jquery 单独打包)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  node_modules的库会打包到一起，但是很多库的时候打包输出的js文件就太大了</span><br><span class="line">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span><br><span class="line">  当运行webpack时，默认查找webpack.config.js配置文件</span><br><span class="line">  需求：需要运行webpack.dll.js文件</span><br><span class="line">    --&gt; webpack --config webpack.dll.js（运行这个指令表示以这个配置文件打包）</span><br><span class="line">*/</span><br><span class="line">const &#123; resolve &#125; = require(&#x27;path&#x27;);</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 最终打包生成的[name] --&gt; jquery</span><br><span class="line">    // [&#x27;jquery] --&gt; 要打包的库是jquery</span><br><span class="line">    jquery: [&#x27;jquery&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 输出出口指定</span><br><span class="line">    filename: &#x27;[name].js&#x27;, // name就是jquery</span><br><span class="line">    path: resolve(__dirname, &#x27;dll&#x27;), // 打包到dll目录下</span><br><span class="line">    library: &#x27;[name]_[hash]&#x27;, // 打包的库里面向外暴露出去的内容叫什么名字</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 打包生成一个manifest.json --&gt; 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称）</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      name: &#x27;[name]_[hash]&#x27;, // 映射库的暴露的内容名称</span><br><span class="line">      path: resolve(__dirname, &#x27;dll/manifest.json&#x27;) // 输出文件路径</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#x27;production&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入插件</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;);</span><br><span class="line">const AddAssetHtmlWebpackPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">// plugins中配置：</span><br><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &#x27;./src/index.html&#x27;</span><br><span class="line">  &#125;),</span><br><span class="line">  // 告诉webpack哪些库不参与打包，同时使用时的名称也得变</span><br><span class="line">  new webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: resolve(__dirname, &#x27;dll/manifest.json&#x27;)</span><br><span class="line">  &#125;),</span><br><span class="line">  // 将某个文件打包输出到build目录下，并在html中自动引入该资源</span><br><span class="line">  new AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    filepath: resolve(__dirname, &#x27;dll/jquery.js&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-优化代码运行的性能"><a href="#5-2-2-优化代码运行的性能" class="headerlink" title="5.2.2 优化代码运行的性能"></a>5.2.2 优化代码运行的性能</h3><h4 id="5-2-2-1-缓存"><a href="#5-2-2-1-缓存" class="headerlink" title="5.2.2.1 缓存"></a>5.2.2.1 缓存</h4><h4 id="5-2-2-2-tree-shaking（树摇）"><a href="#5-2-2-2-tree-shaking（树摇）" class="headerlink" title="5.2.2.2 tree shaking（树摇）"></a>5.2.2.2 tree shaking（树摇）</h4><p>tree shaking：去除无用代码</p>
<p>前提：1. 必须使用 ES6 模块化 2. 开启 production 环境 （这样就自动会把无用代码去掉）</p>
<p>作用：减少代码体积</p>
<p>在 package.json 中配置：</p>
<p><code>&quot;sideEffects&quot;: false</code> 表示所有代码都没有副作用（都可以进行 tree shaking）</p>
<p>这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）</p>
<p>所以可以配置：<code>&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code> 不会对css/less文件tree shaking处理</p>
<h4 id="5-2-2-3-code-split（代码分割）"><a href="#5-2-2-3-code-split（代码分割）" class="headerlink" title="5.2.2.3 code split（代码分割）"></a>5.2.2.3 code split（代码分割）</h4><p>代码分割。将打包输出的一个大的 bundle.js 文件拆分成多个小文件，这样可以并行加载多个文件，比加载一个文件更快。</p>
<p>1.多入口拆分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单入口</span><br><span class="line">// entry: &#x27;./src/js/index.js&#x27;</span><br><span class="line">entry: &#123; </span><br><span class="line">    // 多入口：有一个入口，最终输出就有一个bundle</span><br><span class="line">    index: &#x27;./src/js/index.js&#x27;,</span><br><span class="line">    test: &#x27;./src/js/test.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // [name]：取文件名</span><br><span class="line">    filename: &#x27;js/[name].[contenthash:10].js&#x27;,</span><br><span class="line">    path: resolve(__dirname, &#x27;build&#x27;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>2.optimization：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &#x27;all&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>将 node_modules 中的代码单独打包（大小超过30kb）</li>
<li>自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(比如两个模块中都引入了jquery会被打包成单独的文件)（大小超过30kb）</li>
</ul>
<p>3.import 动态导入语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  通过js代码，让某个文件被单独打包成一个chunk</span><br><span class="line">  import动态导入语法：能将某个文件单独打包(test文件不会和index打包在同一个文件而是单独打包)</span><br><span class="line">  webpackChunkName:指定test单独打包后文件的名字</span><br><span class="line">*/</span><br><span class="line">import(/* webpackChunkName: &#x27;test&#x27; */&#x27;./test&#x27;)</span><br><span class="line">  .then((&#123; mul, count &#125;) =&gt; &#123;</span><br><span class="line">    // 文件加载成功~</span><br><span class="line">    // eslint-disable-next-line</span><br><span class="line">    console.log(mul(2, 5));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(() =&gt; &#123;</span><br><span class="line">    // eslint-disable-next-line</span><br><span class="line">    console.log(&#x27;文件加载失败~&#x27;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-4-lazy-loading（懒加载-预加载）"><a href="#5-2-2-4-lazy-loading（懒加载-预加载）" class="headerlink" title="5.2.2.4 lazy loading（懒加载/预加载）"></a>5.2.2.4 lazy loading（懒加载/预加载）</h4><p>1.懒加载：当文件需要使用时才加载（需要代码分割）。但是如果资源较大，加载时间就会较长，有延迟。</p>
<p>2.正常加载：可以认为是并行加载（同一时间加载多个文件）没有先后顺序，先加载了不需要的资源就会浪费时间。</p>
<p>3.预加载 prefetch（兼容性很差）：会在使用之前，提前加载。等其他资源加载完毕，浏览器空闲了，再偷偷加载这个资源。这样在使用时已经加载好了，速度很快。所以在懒加载的基础上加上预加载会更好。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.getElementById(&#x27;btn&#x27;).onclick = function() &#123;</span><br><span class="line">  // 将import的内容放在异步回调函数中使用，点击按钮，test.js才会被加载(不会重复加载)</span><br><span class="line">  // webpackPrefetch: true表示开启预加载</span><br><span class="line">  import(/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */&#x27;./test&#x27;).then((&#123; mul &#125;) =&gt; &#123;</span><br><span class="line">    console.log(mul(4, 5));</span><br><span class="line">  &#125;);</span><br><span class="line">  import(&#x27;./test&#x27;).then((&#123; mul &#125;) =&gt; &#123;</span><br><span class="line">    console.log(mul(2, 5))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-5-pwa（离线可访问技术）"><a href="#5-2-2-5-pwa（离线可访问技术）" class="headerlink" title="5.2.2.5 pwa（离线可访问技术）"></a>5.2.2.5 pwa（离线可访问技术）</h4><p>pwa：离线可访问技术（渐进式网络开发应用程序），使用 serviceworker 和 workbox 技术。优点是离线也能访问，缺点是兼容性差。</p>
<p>webpack.config.js 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const WorkboxWebpackPlugin = require(&#x27;workbox-webpack-plugin&#x27;); // 引入插件</span><br><span class="line"></span><br><span class="line">// plugins中加入：</span><br><span class="line">new WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">  /*</span><br><span class="line">    1. 帮助serviceworker快速启动</span><br><span class="line">    2. 删除旧的 serviceworker</span><br><span class="line"></span><br><span class="line">    生成一个 serviceworker 配置文件</span><br><span class="line">  */</span><br><span class="line">  clientsClaim: true,</span><br><span class="line">  skipWaiting: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>index.js 中还需要写一段代码来激活它的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  1. eslint不认识 window、navigator全局变量</span><br><span class="line">    解决：需要修改package.json中eslintConfig配置</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true // 支持浏览器端全局变量</span><br><span class="line">    &#125;</span><br><span class="line">  2. sw代码必须运行在服务器上</span><br><span class="line">    --&gt; nodejs</span><br><span class="line">    或--&gt;</span><br><span class="line">      npm i serve -g</span><br><span class="line">      serve -s build 启动服务器，将打包输出的build目录下所有资源作为静态资源暴露出去</span><br><span class="line">*/</span><br><span class="line">if (&#x27;serviceWorker&#x27; in navigator) &#123; // 处理兼容性问题</span><br><span class="line">  window.addEventListener(&#x27;load&#x27;, () =&gt; &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(&#x27;/service-worker.js&#x27;) // 注册serviceWorker</span><br><span class="line">      .then(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;sw注册成功了~&#x27;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;sw注册失败了~&#x27;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Github知识图谱</title>
    <url>/2021/06/23/Github%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p><img src="/2021/06/23/Github%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Javascript_01.jpg" alt="Javascript"></p>
<p><img src="/2021/06/23/Github%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/HTML_CSS_01.jpg" alt="HTML&amp;CSS"></p>
<p><img src="/2021/06/23/Github%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/algorithms_01.jpg" alt="算法"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>LR使用教程</title>
    <url>/2021/06/20/LR%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h1><p><strong>1.文件夹</strong></p>
<p>文件夹中显示的文件夹是因为你在这些文件夹中导入了照片。</p>
<p><strong>2.照片评分与打标签</strong></p>
<p>在图库中浏览照片时，直接按1-5分别是对当前照片给出对应评分；</p>
<p>剩下的6789是分别给照片打上不同的照片标签：</p>
<p>数字6-红色</p>
<p>数字7-黄色</p>
<p>数字8-绿色</p>
<p>数字9-蓝色</p>
<p><strong>3.收藏夹</strong></p>
<p>当需要标记一个系列的照片时，需要用到收藏夹，选出需要放到同一收藏夹下的照片，全选，添加收藏夹</p>
<p><strong>4.建议工作流程（向下执行）</strong></p>
<p>将今天一天所拍的照片都导入LR中</p>
<p>通过筛选功能筛选出觉得不错的一组或几组照片</p>
<p>将这些照片放到不同的收藏夹中</p>
<p>在未来几天进行反复修改、定色调、定调子等</p>
<p>最后导出到PS进行精修（皮肤修饰、液化等）</p>
<p><strong>5.图库批量操作</strong></p>
<p>图库中可以批量对照片进行操作：比较适合工作量较大而又不需要精修的项目</p>
<h1 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h1><p><strong>1.照片导入问题</strong></p>
<p>导入照片时注意图库上方的导入方法：复制、移动、添加</p>
<p>添加：图片物理位置没有发生改变，只是在软件和图片之间建立了一个索引</p>
<p>移动：会将磁盘中的文件移动到右侧所设置的目标位置中，默认为C盘</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是奇异值分解？(SVD)</title>
    <url>/2021/06/11/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E4%B9%8BSVD/</url>
    <content><![CDATA[<p>一、奇异值与特征值基础知识：</p>
<pre><code>特征值分解和奇异值分解在机器学习领域都是属于满地可见的方法。两者有着很紧密的关系，我在接下来会谈到，特征值分解和奇异值分解的目的都是一样，就是提取出一个矩阵最重要的特征。先谈谈特征值分解吧：
</code></pre>
<p>   1）特征值：</p>
<pre><code>如果说一个向量v是方阵A的特征向量，将一定可以表示成下面的形式：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20181223112521324" alt="img"></p>
<pre><code>这时候λ就被称为特征向量v对应的特征值，一个矩阵的一组特征向量是一组正交向量。特征值分解是将一个矩阵分解成下面的形式：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20181223112521340" alt="image"></p>
<pre><code>其中Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角阵，每一个对角线上的元素就是一个特征值。我这里引用了一些参考文献中的内容来说明一下。首先，要明确的是，一个矩阵其实就是一个线性变换，因为一个矩阵乘以一个向量后得到的向量，其实就相当于将这个向量进行了线性变换。比如说下面的一个矩阵：

   它其实对应的线性变换是下面的形式：

因为这个矩阵M乘以一个向量(x,y)的结果是：

上面的矩阵是对称的，所以这个变换是一个对x，y轴的方向一个拉伸变换（每一个对角线上的元素将会对一个维度进行拉伸变换，当值&gt;1时，是拉长，当值&lt;1时时缩短），当矩阵不是对称的时候，假如说矩阵是下面的样子：













它所描述的变换是下面的样子：



这其实是在平面上对一个轴进行的拉伸变换（如蓝色的箭头所示），在图中，蓝色的箭头是一个最主要的变化方向（变化方向可能有不止一个），如果我们想要描述好一个变换，那我们就描述好这个变换主要的变化方向就好了。反过头来看看之前特征值分解的式子，分解得到的Σ矩阵是一个对角阵，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）

当矩阵是高维的情况下，那么这个矩阵就是高维空间下的一个线性变换，这个线性变化可能没法通过图片来表示，但是可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵（变换）。也就是之前说的：提取这个矩阵最重要的特征。总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么，可以将每一个特征向量理解为一个线性的子空间，我们可以利用这些线性的子空间干很多的事情。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。
</code></pre>
<p>   （说了这么多特征值变换，不知道有没有说清楚，请各位多提提意见。）</p>
<p>   2）奇异值：</p>
<pre><code>下面谈谈奇异值分解。特征值分解是一个提取矩阵特征很不错的方法，但是它只是对方阵而言的，在现实的世界中，我们看到的大部分矩阵都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个N * M的矩阵就不可能是方阵，我们怎样才能描述这样普通的矩阵呢的重要特征呢？奇异值分解可以用来干这个事情，奇异值分解是一个能适用于任意的矩阵的一种分解的方法：

假设A是一个N * M的矩阵，那么得到的U是一个N * N的方阵（里面的向量是正交的，U里面的向量称为左奇异向量），Σ是一个N * M的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），V’(V的转置)是一个N * N的矩阵，里面的向量也是正交的，V里面的向量称为右奇异向量），从图片来反映几个相乘的矩阵的大小可得下面的图片



那么奇异值和特征值是怎么对应起来的呢？首先，我们将一个矩阵A的转置 * A，将会得到一个方阵，我们用这个方阵求特征值可以得到：    这里得到的v，就是我们上面的右奇异向量。此外我们还可以得到：

这里的σ就是上面说的奇异值，u就是上面说的左奇异向量。奇异值σ跟特征值类似，在矩阵Σ中也是从大到小排列，而且σ的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前r大的奇异值来近似描述矩阵，这里定义一下部分奇异值分解：



r是一个远小于m、n的数，这样矩阵的乘法看起来像是下面的样子：













右边的三个矩阵相乘的结果将会是一个接近于A的矩阵，在这儿，r越接近于n，则相乘的结果越接近于A。而这三个矩阵的面积之和（在存储观点来说，矩阵面积越小，存储量就越小）要远远小于原始的矩阵A，我们如果想要压缩空间来表示原矩阵A，我们存下这里的三个矩阵：U、Σ、V就好了。
</code></pre>
<p>二、奇异值的计算：</p>
<pre><code>奇异值的计算是一个难题，是一个O(N^3)的算法。在单机的情况下当然是没问题的，matlab在一秒钟内就可以算出1000 * 1000的矩阵的所有奇异值，但是当矩阵的规模增长的时候，计算的复杂度呈3次方增长，就需要并行计算参与了。Google的吴军老师在数学之美系列谈到SVD的时候，说起Google实现了SVD的并行化算法，说这是对人类的一个贡献，但是也没有给出具体的计算规模，也没有给出太多有价值的信息。

其实SVD还是可以用并行的方式去实现的，在解大规模的矩阵的时候，一般使用迭代的方法，当矩阵的规模很大（比如说上亿）的时候，迭代的次数也可能会上亿次，如果使用Map-Reduce框架去解，则每次Map-Reduce完成的时候，都会涉及到写文件、读文件的操作。个人猜测Google云计算体系中除了Map-Reduce以外应该还有类似于MPI的计算模型，也就是节点之间是保持通信，数据是常驻在内存中的，这种计算模型比Map-Reduce在解决迭代次数非常多的时候，要快了很多倍。

Lanczos迭代就是一种解对称方阵部分特征值的方法（之前谈到了，解A’* A得到的对称方阵的特征值就是解A的右奇异向量），是将一个对称的方程化为一个三对角矩阵再进行求解。按网上的一些文献来看，Google应该是用这种方法去做的奇异值分解的。请见Wikipedia上面的一些引用的论文，如果理解了那些论文，也“几乎”可以做出一个SVD了。

由于奇异值的计算是一个很枯燥，纯数学的过程，而且前人的研究成果（论文中）几乎已经把整个程序的流程图给出来了。更多的关于奇异值计算的部分，将在后面的参考文献中给出，这里不再深入，我还是focus在奇异值的应用中去。
</code></pre>
<p>三、奇异值与主成分分析（PCA）：</p>
<pre><code> 主成分分析在上一节里面也讲了一些，这里主要谈谈如何用SVD去解PCA的问题。PCA的问题其实是一个基的变换，使得变换后的数据有着最大的方差。方差的大小描述的是一个变量的信息量，我们在讲一个东西的稳定性的时候，往往说要减小方差，如果一个模型的方差很大，那就说明模型不稳定了。但是对于我们用于机器学习的数据（主要是训练数据），方差大才有意义，不然输入的数据都是同一个点，那方差就为0了，这样输入的多个数据就等同于一个数据了。以下面这张图为例子：

 这个假设是一个摄像机采集一个物体运动得到的图片，上面的点表示物体运动的位置，假如我们想要用一条直线去拟合这些点，那我们会选择什么方向的线呢？当然是图上标有signal的那条线。如果我们把这些点单纯的投影到x轴或者y轴上，最后在x轴与y轴上得到的方差是相似的（因为这些点的趋势是在45度左右的方向，所以投影到x轴或者y轴上都是类似的），如果我们使用原来的xy坐标系去看这些点，容易看不出来这些点真正的方向是什么。但是如果我们进行坐标系的变化，横轴变成了signal的方向，纵轴变成了noise的方向，则就很容易发现什么方向的方差大，什么方向的方差小了。

一般来说，方差大的方向是信号的方向，方差小的方向是噪声的方向，我们在数据挖掘中或者数字信号处理中，往往要提高信号与噪声的比例，也就是信噪比。对上图来说，如果我们只保留signal方向的数据，也可以对原数据进行不错的近似了。

PCA的全部工作简单点说，就是对原始的空间中顺序地找一组相互正交的坐标轴，第一个轴是使得方差最大的，第二个轴是在与第一个轴正交的平面中使得方差最大的，第三个轴是在与第1、2个轴正交的平面中方差最大的，这样假设在N维空间中，我们可以找到N个这样的坐标轴，我们取前r个去近似这个空间，这样就从一个N维的空间压缩到r维的空间了，但是我们选择的r个坐标轴能够使得空间的压缩使得数据的损失最小。

还是假设我们矩阵每一行表示一个样本，每一列表示一个feature，用矩阵的语言来表示，将一个m * n的矩阵A的进行坐标轴的变化，P就是一个变换的矩阵从一个N维的空间变换到另一个N维的空间，在空间中就会进行一些类似于旋转、拉伸的变化。



而将一个m * n的矩阵A变换成一个m * r的矩阵，这样就会使得本来有n个feature的，变成了有r个feature了（r &lt; n)，这r个其实就是对n个feature的一种提炼，我们就把这个称为feature的压缩。用数学语言表示就是：

但是这个怎么和SVD扯上关系呢？之前谈到，SVD得出的奇异向量也是从奇异值由大到小排列的，按PCA的观点来看，就是方差最大的坐标轴就是第一个奇异向量，方差次大的坐标轴就是第二个奇异向量…我们回忆一下之前得到的SVD式子：

 在矩阵的两边同时乘上一个矩阵V，由于V是一个正交的矩阵，所以V转置乘以V得到单位阵I，所以可以化成后面的式子

 将后面的式子与A * P那个m * n的矩阵变换为m * r的矩阵的式子对照看看，在这里，其实V就是P，也就是一个变化的向量。这里是将一个m * n 的矩阵压缩到一个m * r的矩阵，也就是对列进行压缩，如果我们想对行进行压缩（在PCA的观点下，对行进行压缩可以理解为，将一些相似的sample合并在一起，或者将一些没有太大价值的sample去掉）怎么办呢？同样我们写出一个通用的行压缩例子：

这样就从一个m行的矩阵压缩到一个r行的矩阵了，对SVD来说也是一样的，我们对SVD分解的式子两边乘以U的转置U&#39;

这样我们就得到了对行进行压缩的式子。可以看出，其实PCA几乎可以说是对SVD的一个包装，如果我们实现了SVD，那也就实现了PCA了，而且更好的地方是，有了SVD，我们就可以得到两个方向的PCA，如果我们对A’A进行特征值的分解，只能得到一个方向的PCA。
</code></pre>
<p>四、奇异值与潜在语义索引LSI：</p>
<pre><code> 潜在语义索引（Latent Semantic Indexing）与PCA不太一样，至少不是实现了SVD就可以直接用的，不过LSI也是一个严重依赖于SVD的算法，之前吴军老师在矩阵计算与文本处理中的分类问题中谈到：

“三个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值越大越相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关性。因此，我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。”

 上面这段话可能不太容易理解，不过这就是LSI的精髓内容，我下面举一个例子来说明一下，下面的例子来自LSA tutorial，具体的网址我将在最后的引用中给出：

  这就是一个矩阵，不过不太一样的是，这里的一行表示一个词在哪些title中出现了（一行就是之前说的一维feature），一列表示一个title中有哪些词，（这个矩阵其实是我们之前说的那种一行是一个sample的形式的一种转置，这个会使得我们的左右奇异向量的意义产生变化，但是不会影响我们计算的过程）。比如说T1这个title中就有guide、investing、market、stock四个词，各出现了一次，我们将这个矩阵进行SVD，得到下面的矩阵：

  左奇异向量表示词的一些特性，右奇异向量表示文档的一些特性，中间的奇异值矩阵表示左奇异向量的一行与右奇异向量的一列的重要程序，数字越大越重要。

  继续看这个矩阵还可以发现一些有意思的东西，首先，左奇异向量的第一列表示每一个词的出现频繁程度，虽然不是线性的，但是可以认为是一个大概的描述，比如book是0.15对应文档中出现的2次，investing是0.74对应了文档中出现了9次，rich是0.36对应文档中出现了3次；

  其次，右奇异向量中一的第一行表示每一篇文档中的出现词的个数的近似，比如说，T6是0.49，出现了5个词，T2是0.22，出现了2个词。

  然后我们反过头来看，我们可以将左奇异向量和右奇异向量都取后2维（之前是3维的矩阵），投影到一个平面上，可以得到：

 在图上，每一个红色的点，都表示一个词，每一个蓝色的点，都表示一篇文档，这样我们可以对这些词和文档进行聚类，比如说stock 和 market可以放在一类，因为他们老是出现在一起，real和estate可以放在一类，dads，guide这种词就看起来有点孤立了，我们就不对他们进行合并了。按这样聚类出现的效果，可以提取文档集合中的近义词，这样当用户检索文档的时候，是用语义级别（近义词集合）去检索了，而不是之前的词的级别。这样一减少我们的检索、存储量，因为这样压缩的文档集合和PCA是异曲同工的，二可以提高我们的用户体验，用户输入一个词，我们可以在这个词的近义词的集合中去找，这是传统的索引无法做到的。
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「像我这样迷茫的人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_34662278/article/details/85221254">https://blog.csdn.net/qq_34662278/article/details/85221254</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>SVD</tag>
      </tags>
  </entry>
  <entry>
    <title>B站多媒体资源</title>
    <url>/2021/06/10/B%E7%AB%99%E5%A4%9A%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h3 id="视频类"><a href="#视频类" class="headerlink" title="视频类"></a>视频类</h3><p>1.预告片世界：<a href="https://www.yugaopian.cn/">https://www.yugaopian.cn/</a><br>2.33台词：<a href="http://33.agilestudio.cn/">http://33.agilestudio.cn/</a><br>3.MixKit：<a href="https://mixkit.co/free-stock-video/">https://mixkit.co/free-stock-video/</a><br>4.Pexel：<a href="https://www.pexels.com/zh-cn/video/">https://www.pexels.com/zh-cn/video/</a><br>5.Videezy：<a href="https://www.videezy.com/">https://www.videezy.com/</a><br>6.VJShi：<a href="https://www.vjshi.com/">https://www.vjshi.com/</a> </p>
<h3 id="PPT模板类"><a href="#PPT模板类" class="headerlink" title="PPT模板类"></a>PPT模板类</h3><p>1.51PPT模板：<a href="http://www.51pptmoban.com/">http://www.51pptmoban.com/</a><br>2.优品PPT：<a href="https://www.ypppt.com/">https://www.ypppt.com/</a><br>3.第一PPT：<a href="http://www.1ppt.com/">http://www.1ppt.com/</a><br>4.叮当设计：<a href="https://www.dingdangsheji.com/">https://www.dingdangsheji.com/</a><br>5.PPT超级市场：<a href="http://ppt.sotary.com/web/wxapp/index.html">http://ppt.sotary.com/web/wxapp/index.html</a> </p>
<h3 id="静态图片"><a href="#静态图片" class="headerlink" title="静态图片"></a>静态图片</h3><p>1.PH：<a href="https://pxhere.com/">https://pxhere.com/</a><br>2.CC0图片网：<a href="https://cc0.cn/">https://cc0.cn/</a><br>3.Foodiesfeed：<a href="https://www.foodiesfeed.com/">https://www.foodiesfeed.com/</a><br>4.Unplash：<a href="https://unsplash.com/">https://unsplash.com/</a><br>5.Pixabay：<a href="https://pixabay.com/">https://pixabay.com/</a> </p>
<h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3><p>1.Giphy：<a href="https://giphy.com/">https://giphy.com/</a><br>2.GfyCat：<a href="https://gfycat.com/">https://gfycat.com/</a><br>3.Tenor：<a href="https://tenor.com/">https://tenor.com/</a><br>4.GIF ABYSS：<a href="https://gifs.alphacoders.com/">https://gifs.alphacoders.com/</a><br>5.动图宇宙：<a href="https://biaoqingsoso.com/">https://biaoqingsoso.com/</a><br>6.Soogif：<a href="https://www.soogif.com/">https://www.soogif.com/</a><br>7.闪萌：<a href="http://www.weshineapp.com/">http://www.weshineapp.com/</a></p>
<h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><p>1.WallHaven：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a><br>2.10Wallpaper：<a href="https://www.10wallpaper.com/">https://www.10wallpaper.com/</a><br>3.alphacoders：<a href="https://wall.alphacoders.com/?lang=Chinese">https://wall.alphacoders.com/?lang=Chinese</a><br>4.极简壁纸：<a href="https://bz.zzzmh.cn/index">https://bz.zzzmh.cn/index</a><br>5.3G壁纸：<a href="https://www.3gbizhi.com/">https://www.3gbizhi.com/</a><br>6.必应壁纸：<a href="https://bing.ioliu.cn/">https://bing.ioliu.cn/</a> </p>
<h3 id="图标类"><a href="#图标类" class="headerlink" title="图标类"></a>图标类</h3><p>1.阿里巴巴矢量图库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a><br>2.Ikonate：<a href="https://ikonate.com/">https://ikonate.com/</a><br>3.iconstore：<a href="https://iconstore.co/">https://iconstore.co/</a><br>4.icoon：<a href="https://icooon-mono.com/">https://icooon-mono.com/</a><br>5.iconfinder：<a href="https://www.iconfinder.com/">https://www.iconfinder.com/</a></p>
<h3 id="PSD模板"><a href="#PSD模板" class="headerlink" title="PSD模板"></a>PSD模板</h3><p>1.素材中国：<a href="http://www.sccnn.com/">http://www.sccnn.com/</a><br>2.站长素材：<a href="https://sc.chinaz.com/psd/">https://sc.chinaz.com/psd/</a><br>3.365PSD：<a href="https://cn.365psd.com/free-psd">https://cn.365psd.com/free-psd</a><br>4.freepik：<a href="https://www.freepik.com/psd">https://www.freepik.com/psd</a><br>5.freebiesbug： <a href="https://freebiesbug.com/">https://freebiesbug.com/</a> </p>
<h3 id="音频类"><a href="#音频类" class="headerlink" title="音频类"></a>音频类</h3><p>1.Mixkit：<a href="https://mixkit.co/free-stock-music/">https://mixkit.co/free-stock-music/</a><br>2.爱给网：<a href="https://www.aigei.com/">https://www.aigei.com/</a><br>3.淘声网：<a href="https://www.tosound.com/">https://www.tosound.com/</a><br>4.耳聆：<a href="https://www.ear0.com/">https://www.ear0.com/</a></p>
<h3 id="字体类"><a href="#字体类" class="headerlink" title="字体类"></a>字体类</h3><p>1.素材中国：<a href="http://www.sccnn.com/ziku/">http://www.sccnn.com/ziku/</a><br>2.100Font：<a href="https://www.100font.com/">https://www.100font.com/</a><br>3.DaFont：<a href="https://www.dafont.com/">https://www.dafont.com/</a><br>4.自由字体：<a href="https://ziyouziti.com/">https://ziyouziti.com/</a> </p>
<h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p>1.中国色彩：<a href="http://zhongguose.com/">http://zhongguose.com/</a><br>3.ColorHex：<a href="https://www.colorhexa.com/">https://www.colorhexa.com/</a><br>4.优色网配色专区：<a href="https://color.uisdc.com/">https://color.uisdc.com/</a><br>5.ColorDrop：<a href="https://www.colordrop.io/">https://www.colordrop.io/</a><br>6.LOL Colors：<a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a><br>7.colorHunt：<a href="https://colorhunt.co/">https://colorhunt.co/</a><br>8.Adobe Color：<a href="https://color.adobe.com/zh/create/color-wheel">https://color.adobe.com/zh/create/color-wheel</a><br>9.uigradients：<a href="https://uigradients.com/#PiggyPink">https://uigradients.com/#PiggyPink</a><br>10.webgradient：<a href="https://webgradients.com/">https://webgradients.com/</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>博客管理</title>
    <url>/2021/06/07/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>HEXO是一个较为流行的博客框架，本博客就是基于这个框架搭建，具体的搭建教程可见B站up主CodeSheep的<a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=13159882610131420769">教程</a>。另外，此博客所用主题为melody，个人比较喜欢这样简约中又略带动效的风格，这篇文章主要用来记录我在搭建博客过程中的一些使用技巧与心得，若文中有问题或错误希望各位指出，与君共勉。</p>
<p>下面是一些关于搭建完成后的文件说明：</p>
<p>当搭建完成博客后，你所有关于博客的文件都会存在一个你自己在搭建过程中建立的文件夹中，例如我的文件夹</p>
<p><img src="/2021/06/07/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/01.jpg" alt="博客所在主文件夹"></p>
<p>如上图所示，所有的关于hexo博客文件的配置均在<code>_config.yml</code>中，而涉及到melody主题的配置则在<code>_config.melody.yml</code>中，注意与文件名机制不同，此博客所使用的主题具体文件并不在themes中，而是在<code>node_modouls</code>文件夹中，如下图<img src="/2021/06/07/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/02.png" alt="主题文件夹"></p>
<p>关于博客文章具体的所有配置文件都存在下面这个文件夹中</p>
<p><img src="/2021/06/07/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/03.png" alt="主题文件夹"></p>
<p>如图所示<code>_post</code>存放我们的所有文章，<code>404</code>存放配置404页面的文件，<code>categories</code>存放文章分类的配置文件，<code>gallery</code>存放博客相册配置文件，<code>slide</code>存放博客滑动的配置文件，<code>tags</code>存放博客文章标签配置文件。</p>
<p>介绍完主要的文件路径，我们来说说对博客的日常管理操作。在平时使用hexo博客时，我们常用到一下以下几个命令：</p>
<ol>
<li>首先确保我们进入的是博客所在文件夹即上面第一张图的<code>blog</code>文件夹路径下，之后在路径栏输入cmd，回车后会弹出该路径下的命令框界面，我们对博客的所有操作都是在当前这个路径下进行；</li>
<li>具体命令：</li>
</ol>
<p><strong>init</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<p>本命令相当于执行了以下几步：</p>
<ol>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li>
<li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li>
</ol>
<p><strong>new</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。注意此处的<code>new</code>可以简写为<code>n</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>, <code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure>

<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>
<p><strong>generate</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>生成静态文件。可以简写为<code>g</code></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code>&nbsp; &nbsp; &nbsp;</td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>, <code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>, <code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>, <code>--concurrency</code>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p><strong>server</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<p><strong>deploy</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo deployj</span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<p><strong>clean</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<p>一般顺序为：hexo n “” -&gt; 编辑文章 -&gt; hexo clean -&gt; hexo g -&gt; hexo s -&gt; 查看本地页面并修改 -&gt; hexo d(通常这一步需要多尝试几次，不知道是不是外网原因还时github不稳定)</p>
<p>以上就是我平时的一些基本使用操作！</p>
<p>此外，是一些使用hexo的小技巧分享：</p>
<p><strong>图片引用方法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">![’这张照片在文章中的名称‘](./<span class="string">&#x27;这篇文章的文件名称(同名文件夹)&#x27;</span>/<span class="string">&#x27;放在文件夹下的照片名称，带后缀&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>举例：<img src="/2021/06/07/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/test.jpg" alt="照片1"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">![照片<span class="number">1</span>](./博客管理/test.jpg)</span><br></pre></td></tr></table></figure>

<p><strong>注意注意！！</strong></p>
<p>引入照片时，在markdown中文件路径中的斜杠是<code>\</code>，这种写法在markdown本地可以显示图片，但是推到博客上就无法显示，想要正确显示图片需要将路径都换成<code>/</code>标志！！</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器机制</title>
    <url>/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 和 GPU 作为计算机中最重要的两个计算单元直接决定了计算性能</p>
<p><img src="https://static001.geekbang.org/infoq/94/9407812940681a84a4b4661b551da819.png" alt="img"></p>
<p>CPU 是计算机的大脑，负责处理各种不同的任务。在过去，大多数 CPU 是单芯片的，核心被安置在同一个芯片上。更新的 CPU 可以支持多核心，运算能力大大加强。而最新的的 cpu 已经达到 10 核心 20 线程数的能力了。</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img src="https://static001.geekbang.org/infoq/8f/8fc555c4a70f7f844dbb34edec74cf1f.png" alt="img"></p>
<p>GPU 是另一个计算机的组成部分，与 CPU 不同，GPU 更擅长利用多核心同时处理单一的任务。像命名那样，GPU 最初被用于处理图像。这就是为什么使用 GPU 可以更快、更顺畅的渲染页面内容。随着 GPU 的发展，越来越多的计算任务也可以使用 GPU 来处理。甚至有人说 GPU 是人工智能的大功臣，可见 GPU 已经不再仅用于图像处理上了。</p>
<h3 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h3><p><img src="https://static001.geekbang.org/infoq/2a/2af38ddf296b92cd6bbbf97322774c33.png" alt="img"></p>
<p>我们可以把计算机自下而上分成三层：硬件、操作系统和应用。有了操作系统的存在，上层运行的应用可以使用操作系统提供的能力使用硬件资源而不会直接访问硬件资源。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p><img src="https://static001.geekbang.org/infoq/97/97afac83d32e43397ea484653bb6b1ec.png" alt="img"></p>
<p>一个进程是应用正在运行的程序。而线程是进程中更小的一部分。当应用被启动，进程就被创建出来。程序可以创建线程来帮助其工作。操作系统会为进程分配私有的内存空间以供使用，当关闭程序时，这段私有的内存也会被释放。其实还有比线程更小的存在就是<strong>协程，而协成是运行在线程中更小的单位。async/await 就是基于协程实现的。</strong></p>
<h3 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h3><p><img src="https://static001.geekbang.org/infoq/b8/b8306ca61a00c7ccfa68476e61a0b105.png" alt="img"></p>
<p>一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以时用 IPC(Inter Process Communication)。</p>
<p>多数程序被设计成使用 IPC 来进行进程间的通信，好处在于当一个进程给另一个进程发消息而没有回应时，并不影响当前的进程继续工作。</p>
<h2 id="Chrome浏览器架构"><a href="#Chrome浏览器架构" class="headerlink" title="Chrome浏览器架构"></a>Chrome浏览器架构</h2><p>借助进程和线程，浏览器可以被设计成单进程、多线程架构，或者利用 IPC 实现多进程、多线程架构。</p>
<p><img src="https://static001.geekbang.org/infoq/23/23162955642bb163b16a5d08bdbb3288.png" alt="img"></p>
<p>这里我们以 Chrome 多进程架构介绍，在 Chrome 中存在着不同种类型的进程，它们各司其职。</p>
<p>浏览器进程：渲染进程、插件进程、GPU进程以及其他实用进程</p>
<p><img src="https://static001.geekbang.org/infoq/89/898bb4e5c529e5d3280b6787a7d261a3.png" alt="img"></p>
<p>浏览器进程作为 Chrome 中最核心的进程，管理着 Chrome 中的其他进程，而渲染进程则负责渲染不同的站点。</p>
<h3 id="进程工作内容"><a href="#进程工作内容" class="headerlink" title="进程工作内容"></a>进程工作内容</h3><p>下面将分别解释各个进程在浏览器中负责的模块</p>
<p><img src="https://static001.geekbang.org/infoq/7b/7bc84e5abe039f836a0af8002d4a63fd.png" alt="img"></p>
<h4 id="浏览器进程（Browser-process）"><a href="#浏览器进程（Browser-process）" class="headerlink" title="浏览器进程（Browser process）"></a>浏览器进程（Browser process）</h4><p>浏览器的主进程（负责协调，主控），只有一个，负责管理浏览器本身，作用有：</p>
<ul>
<li>负责浏览器的界面显示，与用户交互，包括地址栏、书签、前进和后退按钮等</li>
<li>负责各个页面的管理，创建和销毁或是调度其它进程</li>
<li>将渲染进程得到的内存中的<code>Bitmap</code>,绘制到用户界面上</li>
<li>网络资源的管理，网络请求、文件访问，下载等</li>
</ul>
<h4 id="渲染进程（Renderer-process）"><a href="#渲染进程（Renderer-process）" class="headerlink" title="渲染进程（Renderer process）"></a>渲染进程（Renderer process）</h4><p>渲染进程，即浏览器的内核，内部是多线程的，负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理等。默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等。</p>
<h4 id="插件进程（Plugin-process）"><a href="#插件进程（Plugin-process）" class="headerlink" title="插件进程（Plugin process）"></a>插件进程（Plugin process）</h4><p>插件进程负责为浏览器提供各种额外的插件功能，每种类型的插件对应一个进程，仅当使用该插件时才创建，例如逝去的flash。</p>
<h4 id="GPU-进程（GPU-process）"><a href="#GPU-进程（GPU-process）" class="headerlink" title="GPU 进程（GPU process）"></a>GPU 进程（GPU process）</h4><p>GPU 进程最多一个，负责提供成像的功能。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
<p>当然还有其他像扩展进程或工具进程等其他进程，可以在 Chrome 的<code>更多工具-&gt;任务管理器</code>面板中查看，面板中列出了运行的进程和其占用的 CPU、内存情况。</p>
<h3 id="多进程架构的优势"><a href="#多进程架构的优势" class="headerlink" title="多进程架构的优势"></a>多进程架构的优势</h3><ul>
<li>避免单个网页崩溃影响整个浏览器</li>
<li>避免第三方插件崩溃影响整个浏览器</li>
<li>多进程充分利用多核优势</li>
<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>
</ul>
<p>当我们访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当我们在 Chrome 中打开三个页签同时访问三个站点时，如果其中一个没有响应，我们可以关闭它然后使用其他的页签，这是因为 Chrome 为每个站点创建一个独立的渲染进程，专门处理当前站点的渲染工作。如果所有的页面运行在同一个进程中，当有一个页面没有响应时，所有的页面就都卡住了。</p>
<p><img src="https://static001.geekbang.org/infoq/0e/0e8966939127660cee3f7aa05303721b.png" alt="img"></p>
<p>另一个好处是，借助操作系统对进程安全的控制，浏览器中渲染进程都是运行在沙盒（sandbox）模式下，站点的代码可以运行在隔离的环境中，保证核心进程的安全。<code>浏览器进程会给每个渲染进程分配资源，但这些渲染进程只能访问被分配的资源，不能访问未被分配的资源。沙盒用于限制子进程（渲染器、插件、GPU等）直接访问系统资源。这有助于保护用户免受不受信任和潜在恶意Web内容的攻击。</code></p>
<p>虽然多进程的架构优于单进程架构，但由于进程独享自己的私有内存，以渲染进程为例，虽然渲染的站点不同，但工作内容大体相似，为了完成渲染工作它们会在自己的内存中包含相同的功能，例如 V8 引擎（用于解析和运行 Javascript），这意味着这部分相同的功能需要占用每个进程的内存空间。为了节省内存，Chrome 限制了最大进程数，最大进程数取决于硬件的能力，同时<strong>当使用多个页签访问相同的站点时浏览器不会创建新的渲染进程</strong>。</p>
<p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器;<br>当然，内存等资源消耗也会更大，就像空间换时间一样。</p>
<h3 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h3><p> 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。Chrome 将架构从多进程模型转变成面向服务。浏览器将功能以服务的方式提供，以解决多进程架构中的问题。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。</p>
<p>当 Chrome 运行在拥有强大硬件的计算机上时，会将一个服务以多个进程的方式实现，提高稳定性，当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源。</p>
<p><img src="https://static001.geekbang.org/infoq/72/72ab917eee34ffd4b8bb1352a8f73ad6.png" alt="img"></p>
<h2 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><p><img src="https://static001.geekbang.org/infoq/40/4006973a23f68ec28402353d48f91a57.png" alt="img"></p>
<p>浏览器进程负责处理除了渲染外的大部分工作，浏览器进程包括几个线程：</p>
<ul>
<li>UI 线程负责绘制工具栏中的按钮、地址栏等。</li>
<li>网络线程负责从网络中获取数据。</li>
<li>存储线程负责文件等功能。</li>
</ul>
<p>当我们在地址栏中输入一个地址时，浏览器进程中的 UI 线程最先得知这个动作，并开始处理。</p>
<h3 id="一次访问"><a href="#一次访问" class="headerlink" title="一次访问"></a>一次访问</h3><p>下面我们就从一次常见的访问入手，逐步了解浏览器是如何展示页面的。</p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/001.png" alt="示例"></p>
<h4 id="Step-1：输入处理"><a href="#Step-1：输入处理" class="headerlink" title="Step 1：输入处理"></a>Step 1：输入处理</h4><p>当我们在地址栏中输入时，UI 线程会先判断我们输入的内容是要搜索的内容还是要访问一个站点，因为地址栏同时也是一个搜索框。</p>
<p><img src="https://static001.geekbang.org/infoq/d6/d619ac67749e633ae020812aa0b09bdd.png" alt="img"></p>
<h4 id="Step-2：访问开始"><a href="#Step-2：访问开始" class="headerlink" title="Step 2：访问开始"></a>Step 2：访问开始</h4><p>当我们按下回车开始访问时，UI 线程将借助网络线程访问站点资源. 浏览器页签的标题上会出现加载中的图标，同时网络线程会根据适当的网络协议为这次请求建立连接。</p>
<p><img src="https://static001.geekbang.org/infoq/74/749ccda4aca068ed34465407973dc3f9.png" alt="img"></p>
<p>若当服务器返回给浏览器重定向请求时，网络线程会通知 UI 线程需要重定向，然后会以新的地址做开始请求资源。</p>
<h4 id="Step-3：处理响应数据"><a href="#Step-3：处理响应数据" class="headerlink" title="Step 3：处理响应数据"></a>Step 3：处理响应数据</h4><p><img src="https://static001.geekbang.org/infoq/a0/a049bd54e903004676c6f75ec11d373b.png" alt="img"></p>
<p>当网络线程收到来自服务器的数据时，会试图从数据中的前面的一些字节中得到数据的类型（<strong>Content-Type</strong>），以试图了解数据的格式。</p>
<p>当返回的数据类型是 HTML 时，会将数据传递给渲染进程做进一步的渲染工作。但是如果数据类型是 zip 文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或者下载工作。</p>
<p><img src="https://static001.geekbang.org/infoq/b4/b4797a3b5023a9de4ac03ad174e9bd3f.png" alt="img"></p>
<p>在开始渲染之前，网络线程要先检查数据的安全性，这里也是浏览器保证安全的地方。如果返回的数据来自一些恶意的站点，网络线程会显示警告的页面。同时，Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给渲染进程。</p>
<h4 id="Step-4：渲染过程"><a href="#Step-4：渲染过程" class="headerlink" title="Step 4：渲染过程"></a>Step 4：渲染过程</h4><p>当所有的检查结束后，网络线程确信浏览器可以访问站点时，网络线程通知 UI 线程数据已经准备好了。UI 线程会根据当前的站点找到一个渲染进程完成接下来的渲染工作。</p>
<p><img src="https://static001.geekbang.org/infoq/32/320ebdce97d9fb29329fd47c0c5f0c07.png" alt="img"></p>
<p>在第二步，UI 线程将请求地址传递给网络线程时，UI 线程就已经知道了要访问的站点。此时 UI 线程就可以开始查找或启动一个渲染进程，这个动作与让网络线程下载数据是同时的。如果网络线程按照预期获取到数据，则渲染进程就已经可以开始渲染了，这个动作减少了从网络线程开始请求数据到渲染进程可以开始渲染页面的时间。当然，如果出现重定向的请求时，提前初始化的渲染进程可能就不会被使用了，但相比正常访问站点的场景，重定向往往是少数，在实际工作中，也需要根据特定的场景给出特定的方案。</p>
<h4 id="Step-5：提交访问"><a href="#Step-5：提交访问" class="headerlink" title="Step 5：提交访问"></a>Step 5：提交访问</h4><p>经历前面的步骤，数据和渲染进程都已经准备好了。浏览器进程会通过 IPC 向渲染进程提交这次访问，同时也会保证渲染进程可以通过网络线程继续获取数据。一旦浏览器进程收到来自渲染进程的确认完毕的消息，就意味着访问的过程结束了，文档渲染的过程就开始了。</p>
<p>这时，地址栏显示出表明安全的图标，同时显示出站点的信息。访问历史中也会加入当前的站点信息。为了能恢复访问历史信息，当页签或窗口被关闭时，访问历史的信息会被存储在硬盘中。</p>
<p><img src="https://static001.geekbang.org/infoq/b9/b9882cfdfbc700b2698116669bf40d4e.png" alt="img"></p>
<h4 id="Extra-Step：加载完毕"><a href="#Extra-Step：加载完毕" class="headerlink" title="Extra Step：加载完毕"></a>Extra Step：加载完毕</h4><p>当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面。当渲染进程”结束”渲染工作，会给浏览器进程发送消息，这个消息会在页面中所有子页面（frame）结束加载后发出，也就是 onLoad 事件触发后发送。当收到”结束”消息后，UI 线程会隐藏页签标题上的加载状态图标，表明页面加载完毕。</p>
<p>但这里”结束”并不意味着所有的加载工作都结束了，因为可能还有 JavaScript 在加载额外的资源或者渲染新的视图。</p>
<p><img src="https://static001.geekbang.org/infoq/b9/b93f199ad2138be6e445d1ceb4416033.png" alt="img"></p>
<p>访问不同的站点</p>
<p>一次普通的访问到此就结束了。当我们输入另外一个地址时，浏览器进程会重复上面的过程。但是在开始新的访问前，会确认当前的站点是否关心<code>beforeunload</code>事件。<code>当浏览器窗口关闭或者刷新时，会触发beforeunload事件。当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新</code>，<code>beforeunload</code>事件可以提醒用户是否要访问新的站点或者关闭页签，如果用户拒绝则新的访问或关闭会被阻止。</p>
<p>由于所有的包括渲染、运行 Javascript 的工作都发生在渲染进程中，浏览器进程需要在新的访问开始前与渲染进程确认当前的站点是否关心<code>unload</code>，<code>当文档或一个子资源正在被卸载时, 触发 unload事件</code>。</p>
<p><img src="https://static001.geekbang.org/infoq/71/71402d5b3a3f7d5629a242727e606079.png" alt="img"></p>
<p>如果一次访问是从一个渲染进程中发起的，例如用户点击一个链接或者运行 JavaScript 代码<code>location = &#39;http://newsite.com&#39;</code>时，渲染进程首先检查<code>beforeunload</code>。然后再执行和浏览器进程初始化访问同样的步骤，只不过区别在于这样的访问请求是由渲染进程向浏览器进程发起的。</p>
<p>当新的站点请求被创建时，一个独立的渲染进程将被用于处理这个请求。为了支持像<code>unload</code>的事件触发，老的渲染进程需要保持住当前的状态。</p>
<p><img src="https://static001.geekbang.org/infoq/e0/e074926b6b24cae624f6c1c906c16616.png" alt="img"></p>
<h3 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h3><p>Service worker 是一种可以 web 开发者控制缓存的技术。如果 Service worker 被实现成从本地存储获取数据时，那么原本的请求就不会被浏览器发送给服务器了。</p>
<p>值得注意的是，Service worker 中的代码是运行在渲染进程中的。当访问开始时，网络线程会根据域名检查是否有 Service worker 会处理当前地址的请求，如果有，则 UI 线程会找到对应的渲染进程去执行 Service worker 的代码，而 Service worker 可以让开发者决定这个请求是从本地存储还是从网络中获取数据。</p>
<p><img src="https://static001.geekbang.org/infoq/8c/8c45c55d238b901239d0eb4bd40f2892.png" alt="img"></p>
<p><img src="https://static001.geekbang.org/infoq/fd/fdeaee16c665e81bc59f42122080916f.png" alt="img"></p>
<h3 id="访问预加载"><a href="#访问预加载" class="headerlink" title="访问预加载"></a>访问预加载</h3><p>如果 Service worker 最终决定要从网络中获取数据时，我们会发现这种跨进程的通信会造成一些延迟。Navigation Preload是一种可以在 Service worker 启动的同时加载资源的优化机制。借助特殊的请求头，服务器可以决定返回什么样的内容给浏览器。</p>
<p><img src="https://static001.geekbang.org/infoq/21/212631fa2520d730f17b0461ddae71d6.png" alt="img"></p>
<h2 id="渲染进程（浏览器内核）"><a href="#渲染进程（浏览器内核）" class="headerlink" title="渲染进程（浏览器内核）"></a>渲染进程（浏览器内核）</h2><p>浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。</p>
<p>现在我们来介绍一下目前比较常见的浏览器及所使用的内核。</p>
<ul>
<li><p>Chrome浏览器：</p>
<p>Chrome浏览器是google旗下的浏览器。Chrome浏览器至发布以来一直讲究简洁、快速、安全，所以Chrome浏览器到现在一直受人追捧。最开始Chrome采用webkit作为浏览器内核，直到2013年，google宣布不再使用苹果的webkit内核，开始使用webkit的分支内核Blink。</p>
</li>
<li><p>Firefox浏览器：</p>
<p>Firefox浏览器使Mozilla公司旗下浏览器，也是刚才提到的网景公司后来的浏览器。网景被收购后，网景人员创办了Mozilla基金会，这是一个非盈利组织，他们在2004年推出自己的浏览器Firefox。Firefox采用Gecko作为内核。Gecko是一个开源的项目，代码完全公开，因此受到很多人的青睐。Firefox的问世加快了第二次浏览器大战的开始。第二次浏览器大战与第一次二元鼎力的局面不同，这一次的特点就是百家争鸣，也自此打破了IE浏览器从98年网景被收购后独步浏览器市场的局面。</p>
</li>
<li><p>Safari浏览器：</p>
<p>第二次浏览器大战是从苹果公司发布Safari浏览器开始的。2003年，苹果公司在苹果手机上开发Safari浏览器，利用自己得天独厚的手机市场份额使Safari浏览器迅速成为世界主流浏览器。Safari是最早使用webkit内核的浏览器也是现在苹果默认的浏览器。</p>
</li>
<li><p>Opera浏览器：</p>
<p>Opera是挪威Opera Software ASA公司旗下的浏览器。1995年，opera公司发布第一版Opera浏览器，使用自己研发的Presto内核。当时opera公司的开发团队不断完善Presto内核，使Opera浏览器一度成为顶级浏览器。直到2016年奇虎360和昆仑万维收购了Oprea浏览器，从此也丢弃了强大的Presto内核，改用当时Google开源的webkit内核。后来Opera浏览器跟随Google将浏览器内核改为Blink内核。自此Presto内核也淡出了互联网市场。</p>
</li>
<li><p>IE浏览器：</p>
<p>IE是微软公司旗下浏览器，是目国内用户量最多的浏览器。IE诞生于1994年，当时微软为了对抗市场份额占据将近百分之九十的网景Netscape Navigator，于是在Windows中开发了自己的浏览器Internet Explorer，自此也引发了第一次浏览器大战。结果可想而知，微软大获全胜，网景不得不将自己卖给AOL公司。但实际上事情并没有结束，网景后来开发了风靡一时的Firefox火狐，至今Firefox也成为世界五大浏览器之一。</p>
<p>1996年，微软从Spyglass手里拿到Spyglass Mosaic的源代码和授权，开始开发自己的浏览器IE。后来，微软以IE和Windows捆绑的模式不断向市场扩展份额，使IE成为市场的绝对主流。现在装了Windows系统的电脑基本无法卸载IE。</p>
</li>
</ul>
<p>以上是五大浏览器的简介，接下来是四大内核。在介绍五大浏览器的同时也已经顺便介绍了四大内核。四大内核分别是：Trident（也称IE内核）、webkit、Blink、Gecko。五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。像360浏览器、QQ浏览器都是采用双内核。<br> 作为前端开发，熟悉四大内核是非常有必要的。四大内核的解析不同使网页渲染效果更具多样化。下面总结一下各常用浏览器所使用的内核。<br> 1、IE浏览器内核：Trident内核，也是俗称的IE内核；<br> 2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；<br> 3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；<br> 4、Safari浏览器内核：Webkit内核；<br> 5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；<br> 6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；<br> 7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；<br> 8、百度浏览器、世界之窗内核：IE内核；<br> 9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；</p>
<p>介绍完五大主流浏览器及四大内核，那么浏览器内核，也就是渲染进程具体都做了些什么呢？为什么称之为浏览器最重要的部分？</p>
<p>上面提到过，<strong>浏览器是多进程的</strong>，<strong>而浏览器的渲染进程是多线程的</strong></p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/002.png" alt="示例"></p>
<h3 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a><code>GUI</code>渲染线程</h3><ul>
<li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>,构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li>
<li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li>
<li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li>
</ul>
<h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a><code>JS</code>引擎线程</h3><ul>
<li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code> 引擎）。</li>
<li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li>
<li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</li>
<li>同样注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
<h3 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h3><ul>
<li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</li>
<li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li>
<li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li>
</ul>
<h3 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h3><ul>
<li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li>
<li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li>
<li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li>
</ul>
<h3 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步<code>http</code>请求线程</h3><ul>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由<code>JavaScript</code>引擎执行</li>
</ul>
<h3 id="渲染进程渲染页面的内容"><a href="#渲染进程渲染页面的内容" class="headerlink" title="渲染进程渲染页面的内容"></a>渲染进程渲染页面的内容</h3><p>渲染进程最重要的工作就是将 HTML、CSS和 Javascript 代码转换成一个可以与用户产生交互的页面。</p>
<p><img src="https://static001.geekbang.org/infoq/bd/bdfa66a4ef1fbd2805797bc4cd90f8d8.png" alt="img"></p>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>关键渲染路径，指的是浏览器从请求HTML，CSS，JavaScript文件开始，到将它们最终以像素输出到屏幕上这一过程中几个关键的步骤：</p>
<p>1.构建DOM</p>
<ul>
<li>将HTML解析成许多Tokens（此token非彼token）</li>
<li>将Tokens解析成object</li>
<li>将object组合成为一个DOM树</li>
</ul>
<p>2.构建CSSOM</p>
<ul>
<li>解析CSS文件，并构建出一个CSSOM树（过程类似于DOM构建）</li>
</ul>
<p>3.构建Render Tree</p>
<ul>
<li>结合DOM和CSSOM构建出一棵Render Tree</li>
</ul>
<p>4.Layout</p>
<ul>
<li>计算出Render Tree每个节点的具体位置</li>
</ul>
<p>5.Paint</p>
<ul>
<li>将Render tree转换成像素，显示在屏幕上</li>
</ul>
<p><strong>注意</strong>：上面的过程并非依次进行，而是存在一定的交叉</p>
<p>下面的主要介绍渲染进程如何将从网络线程中获取的文本转化成图像的过程。</p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/003.png" alt="示例"></p>
<p>浏览器整个流程如上图所示：</p>
<ol>
<li>当用户输入一个URL时，浏览器就会向服务器发出一个请求，请求URL对应的资源</li>
<li>接受到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一棵DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成以后，才会去构建当前节点的下一个兄弟节点。</li>
<li>将CSS解析成CSSOM树（CSS Rule Tree）</li>
<li>根据DOM树和CSSOM树，来构建Render Tree（渲染树），注意渲染树并不等于DOM树，因为一些像head或display:none的东西，就没有必要放在渲染树中了。</li>
<li>有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义，以及它们的从属关系，下一步操作就是Layout,顾名思义，就是计算出每个节点在屏幕中的位置。</li>
<li>Layout后，浏览器已经知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置是哪里，就进入了最后一步painting，按照算出来的规则，通过显卡，把内容画到屏幕上。</li>
</ol>
<h4 id="DOM-的创建"><a href="#DOM-的创建" class="headerlink" title="DOM 的创建"></a>DOM 的创建</h4><p>当渲染进程接收到来自浏览器进程提交访问的消息后就开始接受HTML数据，用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，并且将其转化成<strong>Document Object Model（DOM）</strong>。</p>
<p>DOM 是一种浏览器内部用于表达页面结构的数据，同时也为 Web 开发者提供了操作页面元素的接口，让 web 开发者可以在 Javascript 代码中获取和操作页面中的元素。</p>
<p>将 HTML 文本转化成 DOM 的标准被<a href="https://html.spec.whatwg.org/">HTML Standard</a>定义。我们会发现在转化过程中浏览器从来不会抛出异常，类似关闭标签的丢失，开始、关闭标签匹配错误等等。这是因为 HTML 标准中定义了要静默的处理这些错误，如果对此感兴趣可以阅读<a href="https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser">An introduction to error handling and strange cases in the parser</a>。</p>
<p>具体到DOM树的构建，如下图：</p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/004.png" alt="示例"></p>
<p>1、当服务器返回一个HTML文件给浏览器的时候，浏览器接受到的是一些字节数据。</p>
<p>2、然后浏览器根据HTTP响应中的编码方式（通过是UTF8），解析字节数据，得到一些字符。如果这个时候编码方式跟文件的字节编码不一致，便会出现乱码。所以我们通过使用&lt;meta http-equiv=”content-type”content=”text/html;charset=utf-8”&gt;来告诉浏览器我们页面使用的是什么编码。</p>
<p>3、这个时候，浏览器再根据DTD（<code>DTD，即文档类型定义，作用是定义XML文档的合法构建模块。它使用一系列的合法元素来定义文档结构。</code>）中的对元素（标签）的定义，对这些接受到的字符进行语义化(token)。DTD常见的有严格、过渡、框架和HTML5三种，负责告诉浏览器，哪些字符是有意义的，哪些字符是无意义的。</p>
<p>4、接着，浏览器再使用这些语义块(token)创建对象，形成一个个节点。</p>
<p>5、然后HTML解析器就会从HTML文件的头部到尾部，一个个地遍历这些节点。当这些节点是普通节点的话，HTML解析器就会将这些节点加入到DOM树中。当这些节点是JS代码的话，HTML解析器就会将控制权交给JS解析器。如果这些节点是CSS代码的话，HTML解析器就会将控制权交给CSS解析器。不过，当外联的JS代码和CSS代码还没从服务器传到浏览器的时候，这个时候如果DOM树上有可视元素的话，浏览器通常会选择在这个时候，将一些内容提前渲染到屏幕上来。</p>
<p>6、当HTML解析器读到最后一个节点的时候，整个DOM树也构建完成了，这个时候就会触发domContentloaded事件。而很多JS库（像JQ）通常会在这个时候有所反应的。</p>
<p>至此，DOM树就全部构建完成了。</p>
<p><strong>构建DOM和CSSOM</strong></p>
<p>DOM 和 CSSOM 都是以”Bytes → characters → tokens → nodes → object model” 这样的方式生成最终的数据。如下图所示：</p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/005.png" alt="示例"></p>
<p>而构建出来的CSSOM是这样的：</p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/006.png" alt="示例"></p>
<p>需要注意的是，上面并不是一颗完整的CSSOM树，文档有一些默认的CSS样式，称作user agent styles，上面只展示了我们覆盖的部分。</p>
<p>如果是外部样式，CSSOM的构建必须要获得一份完整的CSS文件，而不像DOM的构建是一个循序渐进的过程。因为CSS文件中包含大量的样式，后面的样式会覆盖前面的样式，如果我们提前就构建CSSOM，可能会得到错误的结果。</p>
<p><strong>构建Render Tree</strong></p>
<p>浏览器使用DOM和CSSOM构建出Render Tree。此时不像构建DOM一样把所有节点构建出来，浏览器只构建需要在屏幕上显示的部分，因此像<code>&lt;head&gt;</code>，<code>&lt;meta&gt;</code>这些标签就无需构建了。同时，对于<code>display: none</code>的元素，也无需构建。<code>display: none</code>告诉浏览器这个元素无需出现在Render Tree中，但是<code>visibility: hidden</code>只是隐藏了这个元素，但是元素还占空间，会影响到后面的Layout, 因此仍然需要出现在Render Tree中。</p>
<p><img src="/2021/06/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/007.png" alt="示例"></p>
<p>Render Tree的构建过程遵循以下步骤：</p>
<ol>
<li>浏览器从DOM树开始，遍历每一个“可见”节点。</li>
<li>对于每一个”可见”节点，在CSSOM上找到匹配的样式并应用。</li>
<li>生成Render Tree。</li>
</ol>
<p><strong>注意：构建Render Tree这一部分对应后面的Layout过程。</strong></p>
<h4 id="额外资源的加载"><a href="#额外资源的加载" class="headerlink" title="额外资源的加载"></a>额外资源的加载</h4><p>一个网站通常还会使用类似图片，样式文件和 JavaScript 代码等额外的资源。这些资源也需要从网络或缓存中获取。主线程在转化 HTML 的过程中理应挨个加载它们，但是为了提高效率，预加载扫描（Preload Scanner）与转换过程会同时运行着。当预加载扫描在分析器分析 HTML 过程中发现了类似 img 或 link 这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。</p>
<p><img src="https://static001.geekbang.org/infoq/fa/fa689d6a31b8687522c58774c8d9d064.png" alt="img"></p>
<h4 id="JavaScript-会阻塞转化过程"><a href="#JavaScript-会阻塞转化过程" class="headerlink" title="JavaScript 会阻塞转化过程"></a>JavaScript 会阻塞转化过程</h4><p>当 HTML 分析器发现<code>&lt;script&gt;</code>标签时，会暂停接下来的 HTML 转化工作，然后加载、解析并且运行 Javascript 代码。因为在 Javascript 代码中可能会使用类似<code>document.write</code>这样的 API 去改变 DOM 的结构。这就是为什么 HTML 分析器必须等待 Javascript 代码运行结束才能继续分析的原因，也是为什么JavaScript文件在写在底部body标签前的原因。</p>
<h4 id="告诉浏览器要如何加载资源"><a href="#告诉浏览器要如何加载资源" class="headerlink" title="告诉浏览器要如何加载资源"></a>告诉浏览器要如何加载资源</h4><p>如果我们的 Javascript 代码并不需要改变 DOM，可以为<code>&lt;script&gt;</code>标签添加<code>async</code>或<code>defer</code>属性，这样浏览器就会异步的加载这些资源并且不会阻塞 HTML 转化过程。<strong>如果 script 标签是由 JavaScript 代码创建的，标签的 async 属性会默认为 true。</strong>此外我们也可以使用一些预加载技术，比如<code>&lt;link ref=&quot;preload&quot;&gt;</code>来通知浏览器这些资源需要越快下载越好。</p>
<h4 id="样式计算（Style-calculation）"><a href="#样式计算（Style-calculation）" class="headerlink" title="样式计算（Style calculation）"></a>样式计算（Style calculation）</h4><p>对于展示一个页面，光有 DOM 是不够的，因为我们还需要样式来让页面变得更美观。主线程会解析样式（CSS）并决定每个 DOM 元素的样式。这些样式取决于 CSS 选择器的范围，在浏览器开发者工具中我们可以看到这些信息。</p>
<p><img src="https://static001.geekbang.org/infoq/fb/fb7d195814a04c6ed98eab8dbda477c6.png" alt="img"></p>
<p>即使我们没有给 DOM 指定任何的样式，<code>&lt;h1&gt;</code>标签也会比<code>&lt;h2&gt;</code>标签显示的大。这是因为浏览器为不同的标签内置了不同的样式。</p>
<h4 id="布局（layout）"><a href="#布局（layout）" class="headerlink" title="布局（layout）"></a>布局（layout）</h4><p>完成了样式计算工作后，渲染进程已经知道了 DOM 的结构和每个节点的样式，但是依然不足以渲染一个页面。想象一下，让你在电话中向朋友描述一张图：“图中有一个大红色圆和一个小的、蓝色的方块”是不足以让朋友知道这张图到底是什么样的。</p>
<p><img src="https://static001.geekbang.org/infoq/06/0658494542e14f7db66b913c02c03202.png" alt="img"></p>
<p>布局是为元素指定几何信息的过程。主线程遍历 DOM 结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的布局树（Layout tree）。布局树的结构与 DOM 树的结构十分相似，但只包含将会在页面中显示的元素。<strong>当一个元素的样式被设置成 display: none 时，元素就不会出现在布局树中，但那些样式被设置成 visiblility：hidden 的元素会出现在布局树中。</strong>相似的，当我们使用一个包含内容的伪元素（例如<code>p::before &#123; content: &#39;Hi!&#39; &#125;</code>）时，元素会出现在布局树中即使这个元素不存在于 DOM 树中，这也是为什么我们<strong>使用 DOM 提供的 API 无法获取伪元素</strong>的原因。</p>
<p><img src="https://static001.geekbang.org/infoq/0c/0c1de85206f0d177f93a70931a0f8272.png" alt="img"></p>
<p>描述页面布局信息是一项具有挑战性的工作，即使在只有块元素的页面中也必须要考虑字体的大小和在哪里换行，因为在计算下一个元素的位置时需要知道上一个元素的尺寸和形状。</p>
<p><strong>这里还要提到两个概念，一个是回流（Reflow），另一个是重绘（Repaint），这两个部分都属于Render tree阶段</strong></p>
<ul>
<li>Repaint ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</li>
<li>Reflow ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。</li>
<li>Reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 Reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。<br> 注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</li>
<li>所有回流都会干一件事情：根据生成的render tree重新计算所有元素在页面中的位置，所以应该尽可能避免重绘和回流</li>
</ul>
<p><strong>回流一定会触发重绘，而重绘不一定会回流</strong></p>
<h4 id="绘制（Paint）"><a href="#绘制（Paint）" class="headerlink" title="绘制（Paint）"></a>绘制（Paint）</h4><p><img src="https://static001.geekbang.org/infoq/d8/d8fe81b968531c8b3d4767006ea9725d.png" alt="img"></p>
<p>有了 DOM、样式和布局还是无法完成渲染工作。试想，当我们试图复制一张图画。我们知道图画中元素的尺寸、形状和位置，我们还需要知道绘制这些元素的顺序。</p>
<p>例如，当一个元素 z-index 属性被设置后，绘制的顺序会导致渲染成错误的结果。</p>
<p><img src="https://static001.geekbang.org/infoq/11/116fb1ec64e618a7562788911bca8d75.png" alt="img"></p>
<p>在这个阶段，主线程遍历布局树并创建绘制记录，绘制记录是一系列由绘制步骤组成的流程，例如先绘制背景，然后是文字，然后是形状。</p>
<p><img src="https://static001.geekbang.org/infoq/a6/a68fd128fc59b9b2bed3511fcf223c94.png" alt="img"></p>
<h4 id="合成（Compositing）"><a href="#合成（Compositing）" class="headerlink" title="合成（Compositing）"></a>合成（Compositing）</h4><p>现在，浏览器已经知道了文档结构、每一个元素的样式，元素的几何信息，绘制的顺序。将这些信息转化成屏幕上像素的过程叫做光栅化，光栅化是图形学的范畴。</p>
<p><img src="https://static001.geekbang.org/infoq/9e/9ed512afc63c664458faf1bd42247cc0.gif" alt="img"></p>
<p>传统的做法是将可视区域的内容进行光栅化。随着用户滚动页面，不断的光栅化更多的区域。然而对于现代浏览器，有着更复杂的的过程，这个过程被称做合成。</p>
<p><img src="https://static001.geekbang.org/infoq/ae/ae1b6d19e8aeb45841f04bbfa72760dd.gif" alt="img"></p>
<p>合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组合成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层合成新的帧，动画则可以通过移动层来实现。</p>
<h4 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a>层（Layer）</h4><p>为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对开发者来说，当某一部分需要用独立的层渲染，我们可以使用 css 属性<code>will-change</code>让浏览器创建层，关于浏览器如何生成层的标准可自行查阅。</p>
<p><img src="https://static001.geekbang.org/infoq/b0/b08901dee7af151982f600e6a7a6ba43.png" alt="img"></p>
<p>虽然通过分层可以优化浏览器性能，但并不意味着应该给每个元素一个层，过多的层反而影响性能，所以在层的划分上应该具体形况具体分析。</p>
<h4 id="栅格线程与合成线程"><a href="#栅格线程与合成线程" class="headerlink" title="栅格线程与合成线程"></a>栅格线程与合成线程</h4><p>当布局树和绘制顺序确定以后，主线程会将这些信息提交给合成线程。合成线程会光栅化各个层。一个层包含的内容可能是一个完整的页面，也可能是页面的部分，所以合成线程将层拆分成许多块，并将它们发送给栅格线程。栅格线程光栅化这些块并将它们存储在 GPU 缓存中。</p>
<p><img src="https://static001.geekbang.org/infoq/37/371b5fa654d59f0c8ccb2f4f0658c20a.png" alt="img"></p>
<p>合成线程可以决定栅格线程光栅块的优先级，这样可以保证用户能看到的部分可以先被光栅化。一个层也会包含多种块以支持类似缩放这样的功能。</p>
<p>当块被光栅化后，合成线程会使用 draw quads 收集这些信息并创建合成帧（Compositor frame）。</p>
<p><code>Draw quads：存储在缓存中，包含类似块位置这样的信息，用于描述如何使用块合成页面。</code></p>
<p><code>Compositor frame：用于存储表现页面一帧中包含哪些 Draw quads 的集合。</code></p>
<p>然后一个合成帧被提交给浏览器进程。这时如果浏览器 UI 有变化，或者插件的 UI 有变化时，另一个合成帧就会被创建出来。所以每当有交互发生时，合成线程就会创建更多的合成帧然后通过 GPU 将新的部分渲染出来。</p>
<p><img src="https://static001.geekbang.org/infoq/39/397d4949099dd6d1aaffcb55e8678e37.png" alt="img"></p>
<p>合成的好处在于其独立于主线程。合成线程不需要等待样式计算和 Javascript 代码的运行。这也是为什么合成更适合优化交互性能，但如果布局或者绘制需要重新计算则主线程是必须要参与的。</p>
<p>本质上，浏览器的渲染过程就是将文本转换成图像的过程，而当用户与页面发生交互动作时，则显示新的图像。在这个过程中由渲染进程中的主线程完成计算工作，由合成线程和栅格线程完成图像的绘制工作。而在计算过程中，还有强制布局、重排、重绘等更加细节的概念。</p>
<h4 id="从浏览器的角度看事件"><a href="#从浏览器的角度看事件" class="headerlink" title="从浏览器的角度看事件"></a>从浏览器的角度看事件</h4><p>当我们听到事件时，通常会联想到在一个文本框中输入或者单击鼠标，但从浏览器的角度看，输入事件意味着所有的用户动作。鼠标滚轮滚动或者屏幕触摸都是输入事件。</p>
<p>当用户与页面发生交互时，浏览器进程首先接收到事件，然而，浏览器进程只关心事件发生时是在哪个页签中，所以浏览器进程会将事件类型和位置信息等发送给负责当前页签的渲染进程，渲染进程会找到事件发生的元素并且触发事件监听器。</p>
<p><img src="https://static001.geekbang.org/infoq/7f/7f8581ec78d48302c8ea81f713cdfa56.png" alt="img"></p>
<h4 id="合成线程对事件的处理"><a href="#合成线程对事件的处理" class="headerlink" title="合成线程对事件的处理"></a>合成线程对事件的处理</h4><p>在前面的章节中，我们知道了合成线程可以通过合成技术合成不同的光栅层优化性能，如果页面并不监听任何事件，合成线程可以完全独立于主线程生成新的合成帧。但如果页面监听了事件呢？</p>
<p>由于运行 Javascript 是主线程的工作，当页面被合成线程合成过，合成线程会标记那些有事件监听的区域。有了这些信息，当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理。如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。</p>
<p><img src="https://static001.geekbang.org/infoq/6f/6fda6b7355162ca393787e870630a083.png" alt="img"></p>
<h4 id="查找事件目标"><a href="#查找事件目标" class="headerlink" title="查找事件目标"></a>查找事件目标</h4><p><img src="https://static001.geekbang.org/infoq/0e/0eb159798080da4adc7ffb76cf184ffa.png" alt="img"></p>
<p>当渲染线程将事件发送给主线程后，第一件事就是找到事件触发的目标。通过在渲染过程中生成的绘制信息，可以根据坐标找到目标元素。</p>
<h4 id="减少发送给主线程的事件数量"><a href="#减少发送给主线程的事件数量" class="headerlink" title="减少发送给主线程的事件数量"></a>减少发送给主线程的事件数量</h4><p>为了保证动画的顺畅，需要显示器在每秒刷新 60 次。对于典型的触摸事件由合成线程提交给主线程的事件频率可以达到每秒 60-120 次，对于典型的鼠标事件每秒会发送 100 次。事件发送的频率通常比屏幕刷新频率要高。</p>
<p>如果类似<code>touchmove</code>这样的事件每秒向主线程发送 120 次可能会造成主线程执行时间过长而影响性能。</p>
<p><img src="https://static001.geekbang.org/infoq/61/6101cc07df5e744efb2a88208f1d1e52.png" alt="img"></p>
<p>为了减少发送给主线程的事件数量，Chrome 合并了连续的事件。类似<code>wheel</code>，<code>mousewheel</code>，<code>mousemove</code>，<code>pointermove</code>，<code>touchmove</code>这样的事件会被延迟到下一次<code>requestAnimationFrame</code>前触发。<code>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</code></p>
<p><img src="https://static001.geekbang.org/infoq/53/53005a8114a736ca071a333946664ffd.png" alt="img"></p>
<p>而任何的离散事件，类似<code>keydown</code>, <code>keyup</code>, <code>mouseup</code>, <code>mousedown</code>, <code>touchstart</code>和 <code>touchend</code>都会立即被发送给主线程处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>浏览器进程做为最重要的进程负责大多数页签外部的工作，包括地址栏显示、网络请求、页签状态管理等。</li>
<li>不同的渲染进程负责不同的站点渲染工作，渲染进程间彼此独立。</li>
<li>渲染进程在渲染页面的过程中会通过浏览器进程获取站点资源，只有安全的资源才会被渲染进程接收到。</li>
<li>渲染进程中主线程负责除了图像生成外绝大多数工作，如何减少主线程上代码的运行是交互性能优化的关键。</li>
<li>渲染进程中的合成线程和栅格线程负责图像生成，利用分层技术可以优化图像生成的效率。</li>
<li>当用户与页面发生交互时，事件的传播途径从浏览器进程到渲染进程的合成线程再根据事件监听的区域决定是否要传递给渲染进程的主线程处理。</li>
</ul>
<p>参考文章：</p>
<p><a href="https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3">https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3</a></p>
<p><a href="https://www.jianshu.com/p/05eb1b17b298">https://www.jianshu.com/p/05eb1b17b298</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>知识框架</title>
    <url>/2021/06/01/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><img src="/2021/06/01/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png" alt="示例"></p>
<p><img src="/2021/06/01/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF.png" alt="示例"></p>
]]></content>
      <tags>
        <tag>测试文件</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6</title>
    <url>/2021/06/01/ECMAScript-6/</url>
    <content><![CDATA[<h1 id="如何理解ES6"><a href="#如何理解ES6" class="headerlink" title="如何理解ES6"></a>如何理解ES6</h1><h2 id="ECMAScript-是什么？"><a href="#ECMAScript-是什么？" class="headerlink" title="ECMAScript 是什么？"></a>ECMAScript 是什么？</h2><p>相信很多学前端的小伙伴都多多少少听过ES6，但ES6具体是什么东西？又对前端领域有什么作用？这篇博客是我自己在看了网上的资料之后，结合自己的一些理解写下的，希望对大家有所帮助。</p>
<p>首先我们来像这样一个为问题，ECMAScript是什么？它跟JavaScript有什么关系？在做前端领域的练习题时有这样一道题，<img src="/2021/06/01/ECMAScript-6/Users\yuanshan\AppData\Roaming\Typora\typora-user-images\image-20210601202056663.png" alt="image-20210601202056663"></p>
<p>从题目中我们就可以看出来了，ECMAScript是JavaScript的组成部分，JavaScript没了它可是不行的。可是为什么没了它可不行，它有什么作用居然这么重要？</p>
<p>大家再回忆一下，平时我们写javascript代码的时候，用什么声明一个变量，没错，是用关键字：var，为什么是 var 而不是其他的单词？此外，为什么我们都用function关键字来声明一个函数，而不是用其他单词？为什么呢？因为这是ECMAScript规定了我们要这么做，它规定了javascript的语法规则。</p>
<p>再举个栗子，javascript语法中是区分大小写、变量是弱类型的、结尾的分好可有可无、括号表示代码块等等，为什么会有这样的规定？因为这些全都是ECMAScript规定的，我们都要按照它的规定来玩。</p>
<p>再举个栗子，javascript语法中是区分大小写、变量是弱类型的、结尾的分好可有可无、括号表示代码块等等，为什么会有这样的规定？因为这些全都是ECMAScript规定的，我们都要按照它的规定来玩。</p>
<p>如果没有了ECMAScritpt，就好比写作文的时候，内容再精彩，但是整篇文章标点符号胡编乱造，改卷老师也不会给你好的分数，甚至看不懂作文的意思。</p>
<p><strong>ECMAScript就是JavaScript中的语法规范！</strong></p>
<p>大家是否有点头绪了，好像ECMAScript很diao 的样子，可以规定我们怎么去写代码的。没错，它就是辣么diao，而且“后台”很硬，我们来看看它相关的介绍：</p>
<p><em>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer ManufacturersAssociation）通过ECMA-262标准化的脚本程序设计语言。</em></p>
<p>看到了吗，ECMAScript是属于国际标准化的语言，所有浏览器开发商都要按照它制定的标准来开发浏览器。开发者也一样，按照它的规定来编程代码。 </p>
<p>ECMAScript就是这么牛逼哄哄的存在，它规定了我们javascript的最基础的部分！</p>
<h2 id="ECMAScript-的作用-完整版）"><a href="#ECMAScript-的作用-完整版）" class="headerlink" title="ECMAScript 的作用(完整版）"></a>ECMAScript 的作用(完整版）</h2><p>那么，我们现在就知道了，ECMAScript是JavaScript的组成部分，它很重要，它还有其他作用吗？</p>
<p>有的，它还定义了很多重要的东西，包括：</p>
<ul>
<li><strong>语法</strong> – 解析规则，关键字，语句，声明，操作等</li>
<li><strong>类型</strong> – 布尔型，数字，字符串，对象等</li>
<li><strong>原型和继承</strong></li>
<li><strong>内置对象和函数的标准库</strong> – JSON，数字（Math），数组方法，对象内省的方法等等。</li>
</ul>
<p>了解了ECMAScript之后，那什么是ES6呢？</p>
<p>ES6是ECMAScript 6的缩写简称，这个好理解。顾名思义，它是ECMAScript的第6个版本，也就是说它有更早的版本，以后还会有更多版本。</p>
<h2 id="ECMAScript-的历史"><a href="#ECMAScript-的历史" class="headerlink" title="ECMAScript 的历史"></a>ECMAScript 的历史</h2><p>我们大概地了解一下ECMAScript的历史。</p>
<p><strong>1996 年</strong> 11 月，Netscape 公司，决定将 JavaScript 提交给国际标准化组织 ECMA。次年，ECMA发布 ECMAScript。这个版本就是 ECMAScript 1.0 版。</p>
<p><strong>1998 年</strong> 6 月，ECMAScript 2.0 版发布。</p>
<p><strong>1999 年</strong> 12 月，ECMAScript3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。</p>
<p><strong>2007 年</strong> 10 月，ECMAScript4.0 版草案发布，对 3.0 版做了大幅升级，但是，以 Yahoo、Microsoft、Google为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发</p>
<p><strong>2009 年</strong> 12 月，ECMAScript5.0 版正式发布。</p>
<p><strong>2015 年</strong> 6 月，ECMAScript 6 正式通过，成为国际标准。</p>
<h2 id="ES6-为什么受欢迎"><a href="#ES6-为什么受欢迎" class="headerlink" title="ES6 为什么受欢迎"></a>ES6 为什么受欢迎</h2><p>为什么ES6好像挺火的样子？</p>
<p>确实是这样的，对于很多开发者来说，ES6带来的新功能涵盖面很广，还有很多很便利的功能等（如：箭头的功能和简单的字符串插值，不懂没关系，后续陆续介绍），确实令人兴奋。</p>
<p>综合上述ECMAScritpt的介绍，我们认识到了，要学好JavaScript，就必须先学好ECMAScritpt，而且是最新的版本ECMAScritpt。至今为止已经出到ES11，ES12正在规划之中。 </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/06/01/Promise/</url>
    <content><![CDATA[<h2 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h2><p>Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态： **pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</p>
<h2 id="为什么需要promise"><a href="#为什么需要promise" class="headerlink" title="为什么需要promise"></a>为什么需要promise</h2><h3 id="什么是异步回调？"><a href="#什么是异步回调？" class="headerlink" title="什么是异步回调？"></a>什么是异步回调？</h3><p><strong>同步回调：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 3, 5, 7]</span><br><span class="line">      arr.forEach(item =&gt; &#123; // 遍历的回调函数,同步回调函数，不会放入队列</span><br><span class="line">          console.log(item)</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(&#x27;forEach()之后&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>异步回调：</strong></p>
<p>异步回调就是发起请求后，不等待响应就去先干别的事。换句话说，我们现在开始执行的行为，但它们会在稍后完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123; // 异步回调函数，放入队列中将来执行</span><br><span class="line">          console.log(&#x27;timeout callback()&#x27;)</span><br><span class="line">      &#125;, 0)</span><br><span class="line">      console.log(&#x27;setTimeout()之后&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="异步回调存在的问题？"><a href="#异步回调存在的问题？" class="headerlink" title="异步回调存在的问题？"></a>异步回调存在的问题？</h3><ul>
<li>之前处理异步是通过纯粹的回调函数的形式进行处理</li>
<li>很容易进入到回调地狱中，剥夺了函数return的能力</li>
<li>问题可以解决，但是难以读懂，维护困难</li>
<li>稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护</li>
</ul>
<p>​         一般情况我们一次性调用API就可以完成请求。<br>​         有些情况需要多次调用服务器API，就会形成一个链式调用，比如为了完成一个功能，我们需要调用API1、API2、API3，依次按照顺序进行调用，这个时候就会出现回调地狱的问题</p>
<blockquote>
<p>回调地狱/厄运金字塔</p>
</blockquote>
<p>在回调函数中嵌套回调</p>
<p><img src="/2021/06/01/Promise/Users\92898\AppData\Roaming\Typora\typora-user-images\image-20201104123722703.png" alt="image-20201104123722703"></p>
<p>什么是回调地狱？回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p>
<p>回调地狱的缺点？ 不便于阅读/不便于异常处理</p>
<p>解决方案：promise链式调用</p>
<p>终极解决方案：async/await</p>
<blockquote>
<p>实例</p>
</blockquote>
<p>需求：通过ajax请求id，再根据id请求用户名，再根据用户名获取email</p>
<p><strong>而promise解决了回调地狱的问题</strong></p>
<h2 id="Promise的基本使用"><a href="#Promise的基本使用" class="headerlink" title="Promise的基本使用"></a>Promise的基本使用</h2><p>Promise 对象的构造器（constructor）语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>传递给 <code>new Promise</code> 的函数被称为 <strong>executor</strong>。当 <code>new Promise</code> 被创建，executor 会自动运行。</p>
<p>它的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调。我们的代码仅在 executor 的内部。</p>
<p>Promise接受一个函数作为参数，在参数函数中接受两个参数，resolve和reject。当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：</p>
<ul>
<li><code>resolve(value)</code> — 如果任务成功完成并带有结果 <code>value</code>。</li>
<li><code>reject(error)</code> — 如果出现了 error，<code>error</code> 即为 error 对象。</li>
</ul>
<p>总结：executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 <code>resolve</code>，如果出现 error 则调用 <code>reject</code>。</p>
<p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 实例对象具有以下内部属性：</p>
<ul>
<li><code>state</code> — 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li>
<li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li>
</ul>
<p><img src="/2021/06/01/Promise/Users\92898\AppData\Roaming\Typora\typora-user-images\image-20201104123548462.png" alt="image-20201104123548462"></p>
<h3 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h3><p>状态一：pending(准备，待解决，进行中)</p>
<p>状态二：fulfilled(已完成，成功)</p>
<p>状态三：rejected(已拒绝，失败)</p>
<h3 id="promise状态的改变"><a href="#promise状态的改变" class="headerlink" title="promise状态的改变"></a>promise状态的改变</h3><p>通过调用resolve()和reject()改变当前promise对象的状态</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">     resolve()</span><br><span class="line"></span><br><span class="line">     //reject()</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   console.log(p)// fulfilled</span><br></pre></td></tr></table></figure>

<p>resolve():调用此函数，使当前promise对象的状态改为fulfilled</p>
<p>reject():调用此函数，使当前promise对象的状态改为rejected</p>
<p>注意：promise状态的改变是一次性的</p>
<h3 id="promise的结果"><a href="#promise的结果" class="headerlink" title="promise的结果"></a>promise的结果</h3><blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            resolve(&#x27;成功的结果&#x27;)</span><br><span class="line">            // reject()</span><br><span class="line">        &#125;)</span><br><span class="line">        console.log(p)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>通过调用resolve，传递参数，改变当前promise对象的结果</p>
<h2 id="Promise的方法"><a href="#Promise的方法" class="headerlink" title="Promise的方法"></a>Promise的方法</h2><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            resolve(&#x27;成功的结果&#x27;)</span><br><span class="line">            // reject()</span><br><span class="line">        &#125;)</span><br><span class="line">        p.then(() =&gt; &#123;</span><br><span class="line">            // 当promise的状态是fulfilled时执行</span><br><span class="line">            console.log(&#x27;成功的调用&#x27;)</span><br><span class="line">        &#125;),() =&gt; &#123;</span><br><span class="line">            // 当promise的状态是rejected时执行</span><br><span class="line">            console.log(&#x27;失败的调用&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>then方法函数，内部具有两个参数，且这两个参数都是函数</p>
<p><code>.then</code> 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收结果。</p>
<p><code>.then</code> 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error。</p>
<p><strong>理解：</strong></p>
<p><img src="/2021/06/01/Promise/Users\92898\AppData\Roaming\Typora\typora-user-images\image-20201104132226363.png" alt="image-20201104132226363"></p>
<p>setTimeout内涵两个参数，第一个参数是一个函数，第二个参数是执行这个函数的延迟时间，单位为微秒；在上图的例子中，这个函数是一个箭头函数，没有传入值，函数体为resolve(‘成功的数据’)而我们应该注意此处函数体若是resolve，代表回调函数是一个成功的回调，如果是reject则代表是失败的回调；这里的resolve是一个函数体，而里面‘成功的数据’是传入到这个函数体的值，程序运行到这里后将resolve中的值传递给.then中的value，相当于.then的第一个函数体其实就是上面的resolve函数的变体，只不过没有在这里命名为reslove，此时接着执行value这个箭头函数，打印出的值包含value的值，因为此处的value是上面resolve中直接传给的值。</p>
<p>并且then方法的的返回值也是一个Promise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            resolve(&#x27;成功的结果&#x27;)</span><br><span class="line">            // reject()</span><br><span class="line">        &#125;)</span><br><span class="line">        p.then((value) =&gt; &#123;</span><br><span class="line">            // 当promise的状态是fulfilled时执行</span><br><span class="line">            console.log(&#x27;成功的调用&#x27;,value)</span><br><span class="line">        &#125;),(error) =&gt; &#123;</span><br><span class="line">            // 当promise的状态是rejected时执行</span><br><span class="line">            console.log(&#x27;失败的调用&#x27;,error)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="then-链式操作的用法"><a href="#then-链式操作的用法" class="headerlink" title="then 链式操作的用法"></a>then 链式操作的用法</h3><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><strong><code>在then方</code>法的参数函数中，通过形参使用promise对象的结果</strong></li>
<li><strong>若promise的状态不改变，则不会执行then里面的方法</strong></li>
<li><strong>在resolve()中使用return可以将promise示例对象的状态改为fulfilled</strong></li>
<li><strong>若在resolve()出现代码报错情况，会将promise示例对象的状态改变为rejected</strong></li>
<li><strong>then方法返回的还是一个新的Promise对象</strong></li>
<li><strong>then方法的链式操作将嵌套的回调函数由“横向发展”改为“向下发展”</strong></li>
</ol>
<h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><p>如果我们只对 error 感兴趣，那么我们可以使用 <code>null</code> 作为第一个参数：<code>.then(null, errorHandlingFunction)</code>。或者我们也可以使用 <code>.catch(errorHandlingFunction)</code>，其实是一样的：</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;        const p = new Promise((resolve, reject) =&gt; &#123;            throw new Error(&#x27;出错了&#x27;)        &#125;)        p.catch((reason) =&gt; &#123;            console.log(&#x27;失败&#x27;, reason)        &#125;)        console.log(p)&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>catch中的函数参数在什么时候被执行呢？</p>
<p>1.当promise状态改为rejected时被执行</p>
<p>​    reject(‘错误信息’).then(() =&gt; {}, () =&gt; {错误处理逻辑})</p>
<p>2.当promise执行体中出现代码错误时被执行</p>
<pre><code>throw new Error(&#39;错误信息&#39;).catch( () =&gt; &#123;错误处理逻辑&#125;)
</code></pre>
<p>推荐使用第二种方式，更加清晰好读，并且可以捕获前面所有的错误（可以捕获N个then回调错误）</p>
<h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><p><code>finally</code> 是执行清理（cleanup）的很好的处理程序（handler。它与then()的区别在于：</p>
<ol>
<li><code>finally</code> 处理程序没有参数。在 <code>finally</code> 中，我们不知道 promise 是否成功，因为finally通常是用来执行“例行”程序</li>
<li><code>finally</code> 处理程序将结果和 error 传递给下一个处理程序。</li>
</ol>
<h2 id="Promise-内置函数"><a href="#Promise-内置函数" class="headerlink" title="Promise 内置函数"></a>Promise 内置函数</h2><p><code>Promise</code> 内置的 5 种静态方法：</p>
<ol>
<li><p><code>Promise.all(promises)</code> —— 等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 <code>Promise.all</code> 的 error，所有其他 promise 的结果都会被忽略。</p>
<p>例如：Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise<br>它接收一个数组作为参数<br>数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变<br>当所有的子Promise都完成，该Promise完成，返回值是全部值得数组<br>有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果</p>
</li>
<li><pre><code>Promise.allSettled(promises)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   （ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：</span><br><span class="line"></span><br><span class="line">   - `status`: `&quot;fulfilled&quot;` 或 `&quot;rejected&quot;`</span><br><span class="line">   - `value`（如果 fulfilled）或 `reason`（如果 rejected）。</span><br><span class="line"></span><br><span class="line">3. `Promise.race(promises)` —— 等待第一个 settle 的 promise，并将其 result/error 作为结果。</span><br><span class="line"></span><br><span class="line">4. `Promise.resolve(value)` —— 使用给定 value 创建一个 resolved 的 promise。</span><br><span class="line"></span><br><span class="line">5. `Promise.reject(error)` —— 使用给定 error 创建一个 rejected 的 promise。</span><br><span class="line"></span><br><span class="line">## Promise优点</span><br><span class="line"></span><br><span class="line">- promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）</span><br><span class="line">- 并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据</span><br><span class="line">- 代码风格，容易理解，便于维护</span><br><span class="line">- 多个异步等待合并便于解决</span><br><span class="line"></span><br><span class="line">## Promise其他注意事项</span><br><span class="line"></span><br><span class="line">### 如何改变promise的状态？</span><br><span class="line"></span><br><span class="line">（1）resolve(value)：如果当前是pending就会变为resolved</span><br><span class="line"></span><br><span class="line">（2）reject(reason)：如果当前是pending就会变为rejected</span><br><span class="line"></span><br><span class="line">（3）抛出异常：如果当前是pending就会变为rejected</span><br><span class="line"></span><br><span class="line">### 一个promise指定多个成功/失败的回调函数，都会调用吗？</span><br><span class="line"></span><br><span class="line">​	当 promise改变为对应状态时都会调用</span><br><span class="line"></span><br><span class="line">### **一个promise对象只能改变一次状态**</span><br><span class="line"></span><br><span class="line">### 改变promise状态和指定指定回调函数谁先谁后？</span><br><span class="line"></span><br><span class="line">（1）都有可能，正常情况下是先指定回调函数再改变状态，但也可以先改变状态再指定回调函数</span><br><span class="line"></span><br><span class="line">（2）如何先改变状态再指定回调？</span><br><span class="line"></span><br><span class="line">​			1）在执行器中直接调用resolve()/reject()</span><br><span class="line"></span><br><span class="line">​			2）延迟更长时间才调用then()</span><br><span class="line"></span><br><span class="line">（3）什么时候才能得到数据？</span><br><span class="line"></span><br><span class="line">​			1）如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</span><br><span class="line"></span><br><span class="line">​			2）如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</span><br><span class="line"></span><br><span class="line">### promise.then()返回的新promise的结果状态由什么决定？</span><br><span class="line"></span><br><span class="line">（1）简单表述：由then()指定的回调函数执行的结果决定</span><br><span class="line"></span><br><span class="line">（2）详细表述：</span><br><span class="line"></span><br><span class="line">​		1）.如果抛出异常，新promise变为rejected，reason为抛出的异常</span><br><span class="line"></span><br><span class="line">​		2）.如果返回的事非promise的任意值，新promise变为resolved，value为返回的值</span><br><span class="line"></span><br><span class="line">​		3）.如果返回的是另一个新promise，此promise的结果就会变为新promise的结果</span><br><span class="line"></span><br><span class="line">### promise如何串联多个操作任务？</span><br><span class="line"></span><br><span class="line">（1）promise的then返回一个新的promise，可以当成then()的链式调用</span><br><span class="line"></span><br><span class="line">（2）通过then的链式调用串联多个同步/异步任务</span><br><span class="line"></span><br><span class="line">### promise异常穿透</span><br><span class="line"></span><br><span class="line">（1）当使用promise的then链式调用时，可以在最后指定失败的回调</span><br><span class="line"></span><br><span class="line">（2）前面的任何操作出现了异常，都会传到最后失败的回调中处理</span><br><span class="line"></span><br><span class="line">### 中断promise链？</span><br><span class="line"></span><br><span class="line">（1）当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</span><br><span class="line"></span><br><span class="line">（2）方法：在回调函数中返回一个pending状态的promise对象</span><br><span class="line"></span><br><span class="line">## Async/await</span><br><span class="line"></span><br><span class="line">async/await:async是用来取代回调函数的另一种方法，只要当一个函数前面加上了async关键字，就表明函数内部由异步操作，该异步操作返回的是一个Promise对象，前面用await关键字注明。</span><br><span class="line"></span><br><span class="line">当函数执行时，一旦遇到await就会先返回await后面的表达式产生的Promise对象，不再执行函数体内后面的语句，等到触发的异步操作即后面的表达式完成，再接着执行函数体内后面的语句。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
function timeout(ms) &#123;return new Promise((resolve) =&gt; &#123;setTimeout(resolve,ms);&#125;);&#125;async function asyncValue(value) &#123;await timeout(50);return value;&#125;
</code></pre>
</li>
</ol>
<p>上述代码，asyncValue函数前面有async关键字，表明函数体内有异步操作，执行的时候，遇到await就会先返回，等到timeout函数执行完毕，再返回value</p>
<p><img src="/2021/06/01/Promise/YoudaoNote\weixinobU7VjpgAnusht80Jv9s2d_fstRk\2320ca31d8e54ad0bf4d752f364c455b\clipboard.png" alt="img"></p>
<p>函数前面的关键字 <code>async</code> 有两个作用：</p>
<ol>
<li>让这个函数总是返回一个 promise。</li>
<li>允许在该函数内使用 <code>await</code>。</li>
</ol>
<p>Promise 前的关键字 <code>await</code> 使 JavaScript 引擎等待该 promise settle，然后：</p>
<ol>
<li>如果有 error，就会抛出异常 — 就像那里调用了 <code>throw error</code> 一样。</li>
<li>否则，就返回结果。</li>
</ol>
<p>这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。</p>
<p>有了 <code>async/await</code> 之后，我们就几乎不需要使用 <code>promise.then/catch</code>，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待多个任务时，<code>Promise.all</code> 是很好用的。</p>
<p><code>await</code> 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p>
<p>相比于 <code>promise.then</code>，它只是获取 promise 的结果的一个更优雅的语法，同时也更易于读写</p>
<p><strong><code>async/await</code> 和 <code>promise.then/catch</code></strong></p>
<p>当我们使用 <code>async/await</code> 时，几乎就不会用到 <code>.then</code> 了，因为 <code>await</code> 为我们处理了等待。并且我们使用常规的 <code>try..catch</code> 而不是 <code>.catch</code>。这通常（但不总是）更加方便。</p>
<p>但是当我们在代码的顶层时，也就是在所有 <code>async</code> 函数之外，我们在语法上就不能使用 <code>await</code> 了，所以这时候通常的做法是添加 <code>.then/catch</code> 来处理最终的结果（result）或掉出来的（falling-through）error，例如像上面那个例子中的 <code>(*)</code> 行那样</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>__ob__: Observer</title>
    <url>/2021/05/31/ob-Observer/</url>
    <content><![CDATA[<p><code>__ob__</code>: Observer这些数据是vue这个框架对数据设置的监控器，一般都是不可枚举的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.keys()详解</title>
    <url>/2021/05/31/Object-keys-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p><strong>Object.keys()</strong> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line">参数：要返回其枚举自身属性的对象</span><br><span class="line">返回值：一个表示给定对象的所有可枚举属性的字符串数组</span><br></pre></td></tr></table></figure>

<h4 id="处理对象，返回可枚举的属性数组"><a href="#处理对象，返回可枚举的属性数组" class="headerlink" title="处理对象，返回可枚举的属性数组"></a><strong>处理对象，返回可枚举的属性数组</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Object.keys()处理对象，返回可枚举的属性数组<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> person=&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="attr">name</span>:<span class="string">&#x27;一只流浪的kk&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="attr">age</span>:<span class="number">20</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="attr">eat</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));<span class="comment">//    [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;eat&#x27;]</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="处理数组，返回索引值数组"><a href="#处理数组，返回索引值数组" class="headerlink" title="处理数组，返回索引值数组"></a><strong>处理数组，返回索引值数组</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Object.keys()处理数组，返回索引值数组<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr));<span class="comment">//[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;]</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="处理字符串，返回索引值数组"><a href="#处理字符串，返回索引值数组" class="headerlink" title="处理字符串，返回索引值数组"></a><strong>处理字符串</strong>，返回索引值数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Object.keys()处理字符串，返回索引值数组<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> str=<span class="string">&#x27;hello&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(str));<span class="comment">//[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">           <span class="keyword">let</span> person=&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                   <span class="attr">name</span>:<span class="string">&#x27;一只流浪的kk&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                   <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                   <span class="attr">eat</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                       </span></span></span><br><span class="line"><span class="javascript"><span class="xml">                   &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">           &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">           <span class="built_in">Object</span>.keys(person).map(<span class="function">(<span class="params">key</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                   person[key];<span class="comment">//获得属性对应的值，可以进行其它处理</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">           &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="Object-values-和Object-keys-是相反的操作，把一个对象的值转换为数组"><a href="#Object-values-和Object-keys-是相反的操作，把一个对象的值转换为数组" class="headerlink" title="Object.values()和Object.keys()是相反的操作，把一个对象的值转换为数组"></a><strong>Object.values()和Object.keys()是相反的操作，把一个对象的值转换为数组</strong></h4><p> 注意：在ES5里，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 TypeError。在ES2015中，非对象的参数将被强制转换为一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// TypeError: &quot;foo&quot; is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]                   (ES2015 code)</span></span><br></pre></td></tr></table></figure>



<p><strong>转摘自：</strong><a href="https://www.cnblogs.com/jjgw/p/11647012.html">https://www.cnblogs.com/jjgw/p/11647012.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>slide_test</title>
    <url>/2021/05/30/slide-test/</url>
    <content><![CDATA[<h3 id="hexo-theme-melody-v1-5"><a href="#hexo-theme-melody-v1-5" class="headerlink" title="hexo-theme-melody v1.5"></a>hexo-theme-melody <small>v1.5</small></h3><!-- .slide: data-background="#49B1F5" -->

<p>Supports iframe &amp; slides. You can use a layout called <code>slides</code> to enabled the slides layout.</p>
<p>Also you can add a <code>iframe</code> front-matter with the <code>slides</code> layout in your <code>md</code> file to enable the iframe page.</p>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><!-- .slide: data-transition="concave" data-background="#C7916B" -->

<h4 id="1-Add-a-slides-page"><a href="#1-Add-a-slides-page" class="headerlink" title="1. Add a slides page"></a>1. Add a slides page</h4><p>// ……</p>
<p>–</p>
<p>// ……</p>
<hr>
<h4 id="2-Add-the-layout-type"><a href="#2-Add-the-layout-type" class="headerlink" title="2. Add the layout type"></a>2. Add the layout type</h4><!-- .slide: data-transition="fade" data-background="#00C4B6" -->

<p>// ……</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
